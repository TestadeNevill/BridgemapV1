{"ast":null,"code":"import { useRef, createElement, useContext, useCallback, useEffect, useMemo, Fragment, useState, useReducer } from 'react';\nimport PropTypes from 'prop-types';\nimport { forwardRefWithAs, makeId, useCheckStyles, isFunction, useUpdateEffect, useForkedRef, getOwnerDocument, useIsomorphicLayoutEffect, wrapEvent, useLazyRef, createNamedContext, noop } from '@reach/utils';\nimport { useDescendantsInit, DescendantProvider, useDescendant, useDescendants, createDescendantContext } from '@reach/descendants';\nimport { findAll } from 'highlight-words-core';\nimport { useId } from '@reach/auto-id';\nimport { Popover, positionMatchWidth } from '@reach/popover';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar _on, _on2, _on3, _on4, _states; // States\n// Nothing going on, waiting for the user to type or use the arrow keys\n\n\nvar IDLE = \"IDLE\"; // The component is suggesting options as the user types\n\nvar SUGGESTING = \"SUGGESTING\"; // The user is using the keyboard to navigate the list, not typing\n\nvar NAVIGATING = \"NAVIGATING\"; // The user is interacting with arbitrary elements inside the popup that\n// are not ComboboxInputs\n\nvar INTERACTING = \"INTERACTING\"; ////////////////////////////////////////////////////////////////////////////////\n// Events\n// User cleared the value w/ backspace, but input still has focus\n\nvar CLEAR = \"CLEAR\"; // User is typing\n\nvar CHANGE = \"CHANGE\"; // Initial input value change handler for syncing user state with state machine\n// Prevents initial change from sending the user to the NAVIGATING state\n// https://github.com/reach/reach-ui/issues/464\n\nvar INITIAL_CHANGE = \"INITIAL_CHANGE\"; // User is navigating w/ the keyboard\n\nvar NAVIGATE = \"NAVIGATE\"; // User can be navigating with keyboard and then click instead, we want the\n// value from the click, not the current nav item\n\nvar SELECT_WITH_KEYBOARD = \"SELECT_WITH_KEYBOARD\";\nvar SELECT_WITH_CLICK = \"SELECT_WITH_CLICK\"; // Pretty self-explanatory, user can hit escape or blur to close the popover\n\nvar ESCAPE = \"ESCAPE\";\nvar BLUR = \"BLUR\"; // The user left the input to interact with arbitrary elements inside the popup\n\nvar INTERACT = \"INTERACT\";\nvar FOCUS = \"FOCUS\";\nvar OPEN_WITH_BUTTON = \"OPEN_WITH_BUTTON\";\nvar CLOSE_WITH_BUTTON = \"CLOSE_WITH_BUTTON\"; ////////////////////////////////////////////////////////////////////////////////\n\nvar stateChart = {\n  initial: IDLE,\n  states: (_states = {}, _states[IDLE] = {\n    on: (_on = {}, _on[BLUR] = IDLE, _on[CLEAR] = IDLE, _on[CHANGE] = SUGGESTING, _on[INITIAL_CHANGE] = IDLE, _on[FOCUS] = SUGGESTING, _on[NAVIGATE] = NAVIGATING, _on[OPEN_WITH_BUTTON] = SUGGESTING, _on)\n  }, _states[SUGGESTING] = {\n    on: (_on2 = {}, _on2[CHANGE] = SUGGESTING, _on2[FOCUS] = SUGGESTING, _on2[NAVIGATE] = NAVIGATING, _on2[CLEAR] = IDLE, _on2[ESCAPE] = IDLE, _on2[BLUR] = IDLE, _on2[SELECT_WITH_CLICK] = IDLE, _on2[INTERACT] = INTERACTING, _on2[CLOSE_WITH_BUTTON] = IDLE, _on2)\n  }, _states[NAVIGATING] = {\n    on: (_on3 = {}, _on3[CHANGE] = SUGGESTING, _on3[FOCUS] = SUGGESTING, _on3[CLEAR] = IDLE, _on3[BLUR] = IDLE, _on3[ESCAPE] = IDLE, _on3[NAVIGATE] = NAVIGATING, _on3[SELECT_WITH_CLICK] = IDLE, _on3[SELECT_WITH_KEYBOARD] = IDLE, _on3[CLOSE_WITH_BUTTON] = IDLE, _on3[INTERACT] = INTERACTING, _on3)\n  }, _states[INTERACTING] = {\n    on: (_on4 = {}, _on4[CLEAR] = IDLE, _on4[CHANGE] = SUGGESTING, _on4[FOCUS] = SUGGESTING, _on4[BLUR] = IDLE, _on4[ESCAPE] = IDLE, _on4[NAVIGATE] = NAVIGATING, _on4[CLOSE_WITH_BUTTON] = IDLE, _on4[SELECT_WITH_CLICK] = IDLE, _on4)\n  }, _states)\n};\n\nvar reducer = function reducer(data, event) {\n  var nextState = _extends({}, data, {\n    lastEventType: event.type\n  });\n\n  switch (event.type) {\n    case CHANGE:\n    case INITIAL_CHANGE:\n      return _extends({}, nextState, {\n        navigationValue: null,\n        value: event.value\n      });\n\n    case NAVIGATE:\n    case OPEN_WITH_BUTTON:\n      return _extends({}, nextState, {\n        navigationValue: findNavigationValue(nextState, event)\n      });\n\n    case CLEAR:\n      return _extends({}, nextState, {\n        value: \"\",\n        navigationValue: null\n      });\n\n    case BLUR:\n    case ESCAPE:\n      return _extends({}, nextState, {\n        navigationValue: null\n      });\n\n    case SELECT_WITH_CLICK:\n      return _extends({}, nextState, {\n        value: event.value,\n        navigationValue: null\n      });\n\n    case SELECT_WITH_KEYBOARD:\n      return _extends({}, nextState, {\n        value: data.navigationValue,\n        navigationValue: null\n      });\n\n    case CLOSE_WITH_BUTTON:\n      return _extends({}, nextState, {\n        navigationValue: null\n      });\n\n    case INTERACT:\n      return nextState;\n\n    case FOCUS:\n      return _extends({}, nextState, {\n        navigationValue: findNavigationValue(nextState, event)\n      });\n\n    default:\n      return nextState;\n  }\n};\n\nfunction popoverIsExpanded(state) {\n  return [SUGGESTING, NAVIGATING, INTERACTING].includes(state);\n}\n/**\r\n * When we open a list, set the navigation value to the value in the input, if\r\n * it's in the list, then it'll automatically be highlighted.\r\n *\r\n * @param stateData\r\n * @param event\r\n */\n\n\nfunction findNavigationValue(stateData, event) {\n  // @ts-ignore\n  if (event.value) {\n    // @ts-ignore\n    return event.value; // @ts-ignore\n  } else if (event.persistSelection) {\n    return stateData.value;\n  } else {\n    return null;\n  }\n}\n\nvar ComboboxDescendantContext = /*#__PURE__*/createDescendantContext(\"ComboboxDescendantContext\");\nvar ComboboxContext = /*#__PURE__*/createNamedContext(\"ComboboxContext\", {}); // Allows us to put the option's value on context so that ComboboxOptionText\n// can work it's highlight text magic no matter what else is rendered around\n// it.\n\nvar OptionContext = /*#__PURE__*/createNamedContext(\"OptionContext\", {}); ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * Combobox\r\n *\r\n * @see Docs https://reach.tech/combobox#combobox\r\n */\n\nvar Combobox = /*#__PURE__*/forwardRefWithAs(function Combobox(_ref, forwardedRef) {\n  var onSelect = _ref.onSelect,\n      _ref$openOnFocus = _ref.openOnFocus,\n      openOnFocus = _ref$openOnFocus === void 0 ? false : _ref$openOnFocus,\n      children = _ref.children,\n      _ref$as = _ref.as,\n      Comp = _ref$as === void 0 ? \"div\" : _ref$as,\n      ariaLabel = _ref[\"aria-label\"],\n      ariaLabelledby = _ref[\"aria-labelledby\"],\n      props = _objectWithoutPropertiesLoose(_ref, [\"onSelect\", \"openOnFocus\", \"children\", \"as\", \"aria-label\", \"aria-labelledby\"]);\n\n  var _useDescendantsInit = useDescendantsInit(),\n      options = _useDescendantsInit[0],\n      setOptions = _useDescendantsInit[1]; // Need this to focus it\n\n\n  var inputRef = useRef();\n  var popoverRef = useRef();\n  var buttonRef = useRef(); // When <ComboboxInput autocomplete={false} /> we don't want cycle back to\n  // the user's value while navigating (because it's always the user's value),\n  // but we need to know this in useKeyDown which is far away from the prop\n  // here, so we do something sneaky and write it to this ref on context so we\n  // can use it anywhere else 😛. Another new trick for me and I'm excited\n  // about this one too!\n\n  var autocompletePropRef = useRef();\n  var persistSelectionRef = useRef();\n  var defaultData = {\n    // The value the user has typed. We derive this also when the developer is\n    // controlling the value of ComboboxInput.\n    value: \"\",\n    // the value the user has navigated to with the keyboard\n    navigationValue: null\n  };\n\n  var _useReducerMachine = useReducerMachine(stateChart, reducer, defaultData),\n      state = _useReducerMachine[0],\n      data = _useReducerMachine[1],\n      transition = _useReducerMachine[2];\n\n  useFocusManagement(data.lastEventType, inputRef);\n  var id = useId(props.id);\n  var listboxId = id ? makeId(\"listbox\", id) : \"listbox\";\n  var context = {\n    ariaLabel: ariaLabel,\n    ariaLabelledby: ariaLabelledby,\n    autocompletePropRef: autocompletePropRef,\n    buttonRef: buttonRef,\n    comboboxId: id,\n    data: data,\n    inputRef: inputRef,\n    isExpanded: popoverIsExpanded(state),\n    listboxId: listboxId,\n    onSelect: onSelect || noop,\n    openOnFocus: openOnFocus,\n    persistSelectionRef: persistSelectionRef,\n    popoverRef: popoverRef,\n    state: state,\n    transition: transition\n  };\n  useCheckStyles(\"combobox\");\n  return createElement(DescendantProvider, {\n    context: ComboboxDescendantContext,\n    items: options,\n    set: setOptions\n  }, createElement(ComboboxContext.Provider, {\n    value: context\n  }, createElement(Comp, Object.assign({}, props, {\n    \"data-reach-combobox\": \"\",\n    ref: forwardedRef\n  }), isFunction(children) ? children({\n    id: id,\n    isExpanded: popoverIsExpanded(state)\n  }) : children)));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  Combobox.displayName = \"Combobox\";\n  Combobox.propTypes = {\n    as: PropTypes.any,\n    onSelect: PropTypes.func,\n    openOnFocus: PropTypes.bool\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * ComboboxInput\r\n *\r\n * Wraps an `<input/>` with a couple extra props that work with the combobox.\r\n *\r\n * @see Docs https://reach.tech/combobox#comboboxinput\r\n */\n\n\nvar ComboboxInput = /*#__PURE__*/forwardRefWithAs(function ComboboxInput(_ref2, forwardedRef) {\n  var _ref2$as = _ref2.as,\n      Comp = _ref2$as === void 0 ? \"input\" : _ref2$as,\n      _ref2$selectOnClick = _ref2.selectOnClick,\n      selectOnClick = _ref2$selectOnClick === void 0 ? false : _ref2$selectOnClick,\n      _ref2$autocomplete = _ref2.autocomplete,\n      autocomplete = _ref2$autocomplete === void 0 ? true : _ref2$autocomplete,\n      onClick = _ref2.onClick,\n      onChange = _ref2.onChange,\n      onKeyDown = _ref2.onKeyDown,\n      onBlur = _ref2.onBlur,\n      onFocus = _ref2.onFocus,\n      controlledValue = _ref2.value,\n      props = _objectWithoutPropertiesLoose(_ref2, [\"as\", \"selectOnClick\", \"autocomplete\", \"onClick\", \"onChange\", \"onKeyDown\", \"onBlur\", \"onFocus\", \"value\"]); // https://github.com/reach/reach-ui/issues/464\n\n\n  var _React$useRef = useRef(controlledValue),\n      initialControlledValue = _React$useRef.current;\n\n  var controlledValueChangedRef = useRef(false);\n  useUpdateEffect(function () {\n    controlledValueChangedRef.current = true;\n  }, [controlledValue]);\n\n  var _React$useContext = useContext(ComboboxContext),\n      _React$useContext$dat = _React$useContext.data,\n      navigationValue = _React$useContext$dat.navigationValue,\n      value = _React$useContext$dat.value,\n      lastEventType = _React$useContext$dat.lastEventType,\n      inputRef = _React$useContext.inputRef,\n      state = _React$useContext.state,\n      transition = _React$useContext.transition,\n      listboxId = _React$useContext.listboxId,\n      autocompletePropRef = _React$useContext.autocompletePropRef,\n      openOnFocus = _React$useContext.openOnFocus,\n      isExpanded = _React$useContext.isExpanded,\n      ariaLabel = _React$useContext.ariaLabel,\n      ariaLabelledby = _React$useContext.ariaLabelledby;\n\n  var ref = useForkedRef(inputRef, forwardedRef); // Because we close the List on blur, we need to track if the blur is\n  // caused by clicking inside the list, and if so, don't close the List.\n\n  var selectOnClickRef = useRef(false);\n  var handleKeyDown = useKeyDown();\n  var handleBlur = useBlur();\n  var isControlled = controlledValue != null; // Layout effect should be SSR-safe here because we don't actually do\n  // anything with this ref that involves rendering until after we've\n  // let the client hydrate in nested components.\n\n  useIsomorphicLayoutEffect(function () {\n    autocompletePropRef.current = autocomplete;\n  }, [autocomplete, autocompletePropRef]);\n  var handleValueChange = useCallback(function (value) {\n    if (value.trim() === \"\") {\n      transition(CLEAR);\n    } else if (value === initialControlledValue && !controlledValueChangedRef.current) {\n      transition(INITIAL_CHANGE, {\n        value: value\n      });\n    } else {\n      transition(CHANGE, {\n        value: value\n      });\n    }\n  }, [initialControlledValue, transition]);\n  useEffect(function () {\n    // If they are controlling the value we still need to do our transitions,\n    // so  we have this derived state to emulate onChange of the input as we\n    // receive new `value`s ...[*]\n    if (isControlled && controlledValue !== value && ( // https://github.com/reach/reach-ui/issues/481\n    controlledValue.trim() === \"\" ? (value || \"\").trim() !== \"\" : true)) {\n      handleValueChange(controlledValue);\n    }\n  }, [controlledValue, handleValueChange, isControlled, value]); // [*]... and when controlled, we don't trigger handleValueChange as the\n  // user types, instead the developer controls it with the normal input\n  // onChange prop\n\n  function handleChange(event) {\n    var value = event.target.value;\n\n    if (!isControlled) {\n      handleValueChange(value);\n    }\n  }\n\n  function handleFocus() {\n    if (selectOnClick) {\n      selectOnClickRef.current = true;\n    } // If we select an option with click, useFocusManagement will focus the\n    // input, in those cases we don't want to cause the menu to open back up,\n    // so we guard behind these states.\n\n\n    if (openOnFocus && lastEventType !== SELECT_WITH_CLICK) {\n      transition(FOCUS);\n    }\n  }\n\n  function handleClick() {\n    if (selectOnClickRef.current) {\n      selectOnClickRef.current = false;\n      inputRef.current.select();\n    }\n  }\n\n  var inputValue = autocomplete && (state === NAVIGATING || state === INTERACTING) ? // When idle, we don't have a navigationValue on ArrowUp/Down\n  navigationValue || controlledValue || value : controlledValue || value;\n  return createElement(Comp, Object.assign({\n    \"aria-activedescendant\": navigationValue ? String(makeHash(navigationValue)) : undefined,\n    \"aria-autocomplete\": \"both\",\n    \"aria-controls\": listboxId,\n    \"aria-expanded\": isExpanded,\n    \"aria-haspopup\": \"listbox\",\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledby,\n    role: \"combobox\"\n  }, props, {\n    \"data-reach-combobox-input\": \"\",\n    ref: ref,\n    onBlur: wrapEvent(onBlur, handleBlur),\n    onChange: wrapEvent(onChange, handleChange),\n    onClick: wrapEvent(onClick, handleClick),\n    onFocus: wrapEvent(onFocus, handleFocus),\n    onKeyDown: wrapEvent(onKeyDown, handleKeyDown),\n    value: inputValue || \"\"\n  }));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  ComboboxInput.displayName = \"ComboboxInput\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * ComboboxPopover\r\n *\r\n * Contains the popup that renders the list. Because some UI needs to render\r\n * more than the list in the popup, you need to render one of these around the\r\n * list. For example, maybe you want to render the number of results suggested.\r\n *\r\n * @see Docs https://reach.tech/combobox#comboboxpopover\r\n */\n\n\nvar ComboboxPopover = /*#__PURE__*/forwardRefWithAs(function ComboboxPopover(_ref3, forwardedRef) {\n  var _ref3$as = _ref3.as,\n      Comp = _ref3$as === void 0 ? \"div\" : _ref3$as,\n      children = _ref3.children,\n      _ref3$portal = _ref3.portal,\n      portal = _ref3$portal === void 0 ? true : _ref3$portal,\n      onKeyDown = _ref3.onKeyDown,\n      onBlur = _ref3.onBlur,\n      _ref3$position = _ref3.position,\n      position = _ref3$position === void 0 ? positionMatchWidth : _ref3$position,\n      props = _objectWithoutPropertiesLoose(_ref3, [\"as\", \"children\", \"portal\", \"onKeyDown\", \"onBlur\", \"position\"]);\n\n  var _React$useContext2 = useContext(ComboboxContext),\n      popoverRef = _React$useContext2.popoverRef,\n      inputRef = _React$useContext2.inputRef,\n      isExpanded = _React$useContext2.isExpanded;\n\n  var ref = useForkedRef(popoverRef, forwardedRef);\n  var handleKeyDown = useKeyDown();\n  var handleBlur = useBlur();\n  var sharedProps = {\n    \"data-reach-combobox-popover\": \"\",\n    onKeyDown: wrapEvent(onKeyDown, handleKeyDown),\n    onBlur: wrapEvent(onBlur, handleBlur),\n    // Instead of conditionally rendering the popover we use the `hidden` prop\n    // because we don't want to unmount on close (from escape or onSelect).\n    // However, the developer can conditionally render the ComboboxPopover if\n    // they do want to cause mount/unmount based on the app's own data (like\n    // results.length or whatever).\n    hidden: !isExpanded,\n    tabIndex: -1,\n    children: children\n  };\n  return portal ? createElement(Popover, Object.assign({\n    as: Comp\n  }, props, {\n    ref: ref,\n    position: position,\n    targetRef: inputRef\n  }, sharedProps)) : createElement(Comp, Object.assign({\n    ref: ref\n  }, props, sharedProps));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  ComboboxPopover.displayName = \"ComboboxPopover\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * ComboboxList\r\n *\r\n * Contains the `ComboboxOption` elements and sets up the proper aria attributes\r\n * for the list.\r\n *\r\n * @see Docs https://reach.tech/combobox#comboboxlist\r\n */\n\n\nvar ComboboxList = /*#__PURE__*/forwardRefWithAs(function ComboboxList(_ref4, forwardedRef) {\n  var _ref4$persistSelectio = _ref4.persistSelection,\n      persistSelection = _ref4$persistSelectio === void 0 ? false : _ref4$persistSelectio,\n      _ref4$as = _ref4.as,\n      Comp = _ref4$as === void 0 ? \"ul\" : _ref4$as,\n      props = _objectWithoutPropertiesLoose(_ref4, [\"persistSelection\", \"as\"]);\n\n  var _React$useContext3 = useContext(ComboboxContext),\n      persistSelectionRef = _React$useContext3.persistSelectionRef,\n      listboxId = _React$useContext3.listboxId;\n\n  if (persistSelection) {\n    persistSelectionRef.current = true;\n  }\n\n  return createElement(Comp, Object.assign({\n    role: \"listbox\"\n  }, props, {\n    ref: forwardedRef,\n    \"data-reach-combobox-list\": \"\",\n    id: listboxId\n  }));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  ComboboxList.displayName = \"ComboboxList\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * ComboboxOption\r\n *\r\n * An option that is suggested to the user as they interact with the combobox.\r\n *\r\n * @see Docs https://reach.tech/combobox#comboboxoption\r\n */\n\n\nvar ComboboxOption = /*#__PURE__*/forwardRefWithAs(function ComboboxOption(_ref5, forwardedRef) {\n  var _ref5$as = _ref5.as,\n      Comp = _ref5$as === void 0 ? \"li\" : _ref5$as,\n      children = _ref5.children,\n      value = _ref5.value,\n      onClick = _ref5.onClick,\n      props = _objectWithoutPropertiesLoose(_ref5, [\"as\", \"children\", \"value\", \"onClick\"]);\n\n  var _React$useContext4 = useContext(ComboboxContext),\n      onSelect = _React$useContext4.onSelect,\n      navigationValue = _React$useContext4.data.navigationValue,\n      transition = _React$useContext4.transition;\n\n  var ownRef = useRef(null);\n  var ref = useForkedRef(forwardedRef, ownRef);\n  var index = useDescendant({\n    element: ownRef.current,\n    value: value\n  }, ComboboxDescendantContext);\n  var isActive = navigationValue === value;\n\n  var handleClick = function handleClick() {\n    onSelect && onSelect(value);\n    transition(SELECT_WITH_CLICK, {\n      value: value\n    });\n  };\n\n  return createElement(OptionContext.Provider, {\n    value: {\n      value: value,\n      index: index\n    }\n  }, createElement(Comp, Object.assign({\n    \"aria-selected\": isActive,\n    role: \"option\"\n  }, props, {\n    \"data-reach-combobox-option\": \"\",\n    ref: ref,\n    id: String(makeHash(value)),\n    \"data-highlighted\": isActive ? \"\" : undefined,\n    // Without this the menu will close from `onBlur`, but with it the\n    // element can be `document.activeElement` and then our focus checks in\n    // onBlur will work as intended\n    tabIndex: -1,\n    onClick: wrapEvent(onClick, handleClick),\n    children: children || createElement(ComboboxOptionText, null)\n  })));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  ComboboxOption.displayName = \"ComboboxOption\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * ComboboxOptionText\r\n *\r\n * Renders the value of a `ComboboxOption` as text but with spans wrapping the\r\n * matching and non-matching segments of text.\r\n *\r\n * We don't forwardRef or spread props because we render multiple spans or null,\r\n * should be fine 🤙\r\n *\r\n * @example\r\n *   <ComboboxOption value=\"Seattle\">\r\n *     🌧 <ComboboxOptionText />\r\n *   </ComboboxOption>\r\n *\r\n * @see Docs https://reach.tech/combobox#comboboxoptiontext\r\n */\n\n\nfunction ComboboxOptionText() {\n  var _React$useContext5 = useContext(OptionContext),\n      value = _React$useContext5.value;\n\n  var _React$useContext6 = useContext(ComboboxContext),\n      contextValue = _React$useContext6.data.value;\n\n  var results = useMemo(function () {\n    return findAll({\n      searchWords: escapeRegexp(contextValue || \"\").split(/\\s+/),\n      textToHighlight: value\n    });\n  }, [contextValue, value]);\n  return createElement(Fragment, null, results.length ? results.map(function (result, index) {\n    var str = value.slice(result.start, result.end);\n    return createElement(\"span\", {\n      key: index,\n      \"data-user-value\": result.highlight ? true : undefined,\n      \"data-suggested-value\": result.highlight ? undefined : true\n    }, str);\n  }) : value);\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  ComboboxOptionText.displayName = \"ComboboxOptionText\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * ComboboxButton\r\n */\n\n\nvar ComboboxButton = /*#__PURE__*/forwardRefWithAs(function ComboboxButton(_ref6, forwardedRef) {\n  var _ref6$as = _ref6.as,\n      Comp = _ref6$as === void 0 ? \"button\" : _ref6$as,\n      onClick = _ref6.onClick,\n      onKeyDown = _ref6.onKeyDown,\n      props = _objectWithoutPropertiesLoose(_ref6, [\"as\", \"onClick\", \"onKeyDown\"]);\n\n  var _React$useContext7 = useContext(ComboboxContext),\n      transition = _React$useContext7.transition,\n      state = _React$useContext7.state,\n      buttonRef = _React$useContext7.buttonRef,\n      listboxId = _React$useContext7.listboxId,\n      isExpanded = _React$useContext7.isExpanded;\n\n  var ref = useForkedRef(buttonRef, forwardedRef);\n  var handleKeyDown = useKeyDown();\n\n  var handleClick = function handleClick() {\n    if (state === IDLE) {\n      transition(OPEN_WITH_BUTTON);\n    } else {\n      transition(CLOSE_WITH_BUTTON);\n    }\n  };\n\n  return createElement(Comp, Object.assign({\n    \"aria-controls\": listboxId,\n    \"aria-haspopup\": \"listbox\",\n    \"aria-expanded\": isExpanded\n  }, props, {\n    \"data-reach-combobox-button\": \"\",\n    ref: ref,\n    onClick: wrapEvent(onClick, handleClick),\n    onKeyDown: wrapEvent(onKeyDown, handleKeyDown)\n  }));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  ComboboxButton.displayName = \"ComboboxButton\";\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * Move focus back to the input if we start navigating w/ the\r\n * keyboard after focus has moved to any focusable content in\r\n * the popup.\r\n *\r\n * @param lastEventType\r\n * @param inputRef\r\n */\n\n\nfunction useFocusManagement(lastEventType, inputRef) {\n  // useLayoutEffect so that the cursor goes to the end of the input instead\n  // of awkwardly at the beginning, unclear to me why 🤷‍♂️\n  //\n  // Should be safe to use here since we're just focusing an input.\n  useIsomorphicLayoutEffect(function () {\n    if (lastEventType === NAVIGATE || lastEventType === ESCAPE || lastEventType === SELECT_WITH_CLICK || lastEventType === OPEN_WITH_BUTTON) {\n      inputRef.current.focus();\n    }\n  }, [inputRef, lastEventType]);\n}\n/**\r\n * We want the same events when the input or the popup have focus (HOW COOL ARE\r\n * HOOKS BTW?) This is probably the hairiest piece but it's not bad.\r\n */\n\n\nfunction useKeyDown() {\n  var _React$useContext8 = useContext(ComboboxContext),\n      navigationValue = _React$useContext8.data.navigationValue,\n      onSelect = _React$useContext8.onSelect,\n      state = _React$useContext8.state,\n      transition = _React$useContext8.transition,\n      autocompletePropRef = _React$useContext8.autocompletePropRef,\n      persistSelectionRef = _React$useContext8.persistSelectionRef;\n\n  var options = useDescendants(ComboboxDescendantContext);\n  return function handleKeyDown(event) {\n    var index = options.findIndex(function (_ref7) {\n      var value = _ref7.value;\n      return value === navigationValue;\n    });\n\n    function getNextOption() {\n      var atBottom = index === options.length - 1;\n\n      if (atBottom) {\n        if (autocompletePropRef.current) {\n          // Go back to the value the user has typed because we are\n          // autocompleting and they need to be able to get back to what\n          // they had typed w/o having to backspace out.\n          return null;\n        } else {\n          // cycle through\n          return getFirstOption();\n        }\n      } else {\n        // Go to the next item in the list\n        return options[(index + 1) % options.length];\n      }\n    }\n\n    function getPreviousOption() {\n      var atTop = index === 0;\n\n      if (atTop) {\n        if (autocompletePropRef.current) {\n          // Go back to the value the user has typed because we are\n          // autocompleting and they need to be able to get back to what\n          // they had typed w/o having to backspace out.\n          return null;\n        } else {\n          // cycle through\n          return getLastOption();\n        }\n      } else if (index === -1) {\n        // displaying the user's value, so go select the last one\n        return getLastOption();\n      } else {\n        // normal case, select previous\n        return options[(index - 1 + options.length) % options.length];\n      }\n    }\n\n    function getFirstOption() {\n      return options[0];\n    }\n\n    function getLastOption() {\n      return options[options.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        // Don't scroll the page\n        event.preventDefault();\n\n        if (!options || !options.length) {\n          return;\n        }\n\n        if (state === IDLE) {\n          // Opening a closed list\n          transition(NAVIGATE, {\n            persistSelection: persistSelectionRef.current\n          });\n        } else {\n          var next = getNextOption();\n          transition(NAVIGATE, {\n            value: next ? next.value : null\n          });\n        }\n\n        break;\n      // A lot of duplicate code with ArrowDown up next, I'm already over it.\n\n      case \"ArrowUp\":\n        // Don't scroll the page\n        event.preventDefault();\n\n        if (!options || options.length === 0) {\n          return;\n        }\n\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          var prev = getPreviousOption();\n          transition(NAVIGATE, {\n            value: prev ? prev.value : null\n          });\n        }\n\n        break;\n\n      case \"Home\":\n      case \"PageUp\":\n        // Don't scroll the page\n        event.preventDefault();\n\n        if (!options || options.length === 0) {\n          return;\n        }\n\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          transition(NAVIGATE, {\n            value: getFirstOption().value\n          });\n        }\n\n        break;\n\n      case \"End\":\n      case \"PageDown\":\n        // Don't scroll the page\n        event.preventDefault();\n\n        if (!options || options.length === 0) {\n          return;\n        }\n\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          transition(NAVIGATE, {\n            value: getLastOption().value\n          });\n        }\n\n        break;\n\n      case \"Escape\":\n        if (state !== IDLE) {\n          transition(ESCAPE);\n        }\n\n        break;\n\n      case \"Enter\":\n        if (state === NAVIGATING && navigationValue !== null) {\n          // don't want to submit forms\n          event.preventDefault();\n          onSelect && onSelect(navigationValue);\n          transition(SELECT_WITH_KEYBOARD);\n        }\n\n        break;\n    }\n  };\n}\n\nfunction useBlur() {\n  var _React$useContext9 = useContext(ComboboxContext),\n      state = _React$useContext9.state,\n      transition = _React$useContext9.transition,\n      popoverRef = _React$useContext9.popoverRef,\n      inputRef = _React$useContext9.inputRef,\n      buttonRef = _React$useContext9.buttonRef;\n\n  var rafIds = useLazyRef(function () {\n    return new Set();\n  });\n  useEffect(function () {\n    return function () {\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      rafIds.current.forEach(function (id) {\n        return cancelAnimationFrame(id);\n      });\n    };\n  }, [rafIds]);\n  return function handleBlur() {\n    var ownerDocument = getOwnerDocument(popoverRef.current);\n\n    if (!ownerDocument) {\n      return;\n    }\n\n    var rafId = requestAnimationFrame(function () {\n      // we on want to close only if focus propss outside the combobox\n      if (ownerDocument.activeElement !== inputRef.current && ownerDocument.activeElement !== buttonRef.current && popoverRef.current) {\n        if (popoverRef.current.contains(ownerDocument.activeElement)) {\n          // focus landed inside the combobox, keep it open\n          if (state !== INTERACTING) {\n            transition(INTERACT);\n          }\n        } else {\n          // focus landed outside the combobox, close it.\n          transition(BLUR);\n        }\n      }\n    });\n    rafIds.current.add(rafId);\n  };\n}\n/**\r\n * This manages transitions between states with a built in reducer to manage\r\n * the data that goes with those transitions.\r\n *\r\n * @param chart\r\n * @param reducer\r\n * @param initialData\r\n */\n\n\nfunction useReducerMachine(chart, reducer, initialData) {\n  var _React$useState = useState(chart.initial),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  var _React$useReducer = useReducer(reducer, initialData),\n      data = _React$useReducer[0],\n      dispatch = _React$useReducer[1];\n\n  var transition = function transition(event, payload) {\n    if (payload === void 0) {\n      payload = {};\n    }\n\n    var currentState = chart.states[state];\n    var nextState = currentState && currentState.on[event];\n\n    if (nextState) {\n      dispatch(_extends({\n        type: event,\n        state: state,\n        nextState: state\n      }, payload));\n      setState(nextState);\n      return;\n    }\n  };\n\n  return [state, data, transition];\n}\n/**\r\n * We don't want to track the active descendant with indexes because nothing is\r\n * more annoying in a combobox than having it change values RIGHT AS YOU HIT\r\n * ENTER. That only happens if you use the index as your data, rather than\r\n * *your data as your data*. We use this to generate a unique ID based on the\r\n * value of each item.  This function is short, sweet, and good enough™ (I also\r\n * don't know how it works, tbqh)\r\n *\r\n * @see https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript\r\n * @param str\r\n */\n\n\nvar makeHash = function makeHash(str) {\n  var hash = 0;\n\n  if (str.length === 0) {\n    return hash;\n  }\n\n  for (var i = 0; i < str.length; i++) {\n    var _char = str.charCodeAt(i);\n\n    hash = (hash << 5) - hash + _char;\n    hash = hash & hash;\n  }\n\n  return hash;\n};\n/**\r\n * Escape regexp special characters in `str`\r\n *\r\n * @see https://github.com/component/escape-regexp/blob/5ce923c1510c9802b3da972c90b6861dd2829b6b/index.js\r\n * @param str\r\n */\n\n\nfunction escapeRegexp(str) {\n  return String(str).replace(/([.*+?=^!:${}()|[\\]/\\\\])/g, \"\\\\$1\");\n} ////////////////////////////////////////////////////////////////////////////////\n\n/**\r\n * A hook that exposes data for a given `Combobox` component to its descendants.\r\n *\r\n * @see Docs https://reach.tech/combobox#usecomboboxcontext\r\n */\n\n\nfunction useComboboxContext() {\n  var _React$useContext10 = useContext(ComboboxContext),\n      isExpanded = _React$useContext10.isExpanded,\n      comboboxId = _React$useContext10.comboboxId;\n\n  return useMemo(function () {\n    return {\n      id: comboboxId,\n      isExpanded: isExpanded\n    };\n  }, [comboboxId, isExpanded]);\n}\n\nexport { Combobox, ComboboxButton, ComboboxInput, ComboboxList, ComboboxOption, ComboboxOptionText, ComboboxPopover, escapeRegexp, useComboboxContext };","map":{"version":3,"sources":["../src/index.tsx"],"names":["IDLE","SUGGESTING","NAVIGATING","INTERACTING","CLEAR","CHANGE","INITIAL_CHANGE","NAVIGATE","SELECT_WITH_KEYBOARD","SELECT_WITH_CLICK","ESCAPE","BLUR","INTERACT","FOCUS","OPEN_WITH_BUTTON","CLOSE_WITH_BUTTON","stateChart","initial","states","on","reducer","nextState","lastEventType","event","type","navigationValue","value","findNavigationValue","data","stateData","ComboboxDescendantContext","createDescendantContext","ComboboxContext","createNamedContext","OptionContext","Combobox","forwardRefWithAs","onSelect","openOnFocus","children","as","Comp","ariaLabel","ariaLabelledby","props","options","setOptions","useDescendantsInit","inputRef","React","popoverRef","buttonRef","autocompletePropRef","persistSelectionRef","defaultData","state","transition","useReducerMachine","useFocusManagement","id","useId","listboxId","makeId","context","comboboxId","isExpanded","popoverIsExpanded","useCheckStyles","items","set","ref","forwardedRef","PropTypes","bool","ComboboxInput","selectOnClick","autocomplete","onClick","onChange","onKeyDown","onBlur","onFocus","controlledValue","current","initialControlledValue","controlledValueChangedRef","useUpdateEffect","useForkedRef","selectOnClickRef","handleKeyDown","useKeyDown","handleBlur","useBlur","isControlled","useIsomorphicLayoutEffect","handleValueChange","target","inputValue","String","makeHash","undefined","role","wrapEvent","ComboboxPopover","portal","position","positionMatchWidth","sharedProps","hidden","tabIndex","targetRef","ComboboxList","persistSelection","ComboboxOption","ownRef","index","useDescendant","element","isActive","handleClick","ComboboxOptionText","contextValue","results","findAll","searchWords","escapeRegexp","textToHighlight","str","result","key","ComboboxButton","useDescendants","atBottom","getFirstOption","atTop","getLastOption","next","getNextOption","prev","getPreviousOption","rafIds","useLazyRef","cancelAnimationFrame","ownerDocument","getOwnerDocument","rafId","requestAnimationFrame","setState","chart","dispatch","payload","currentState","hash","i","char","useComboboxContext"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCAmDA;AAEA;;;AACA,IAAMA,IAAI,GAAV,MAAA,C,CAAA;;AAGA,IAAMC,UAAU,GAAhB,YAAA,C,CAAA;;AAGA,IAAMC,UAAU,GAAhB,YAAA,C,CAAA;AAGA;;AACA,IAAMC,WAAW,GAAjB,aAAA,C,CAAA;AAGA;AAEA;;AACA,IAAMC,KAAK,GAAX,OAAA,C,CAAA;;AAGA,IAAMC,MAAM,GAAZ,QAAA,C,CAAA;AAGA;AACA;;AACA,IAAMC,cAAc,GAApB,gBAAA,C,CAAA;;AAGA,IAAMC,QAAQ,GAAd,UAAA,C,CAAA;AAGA;;AACA,IAAMC,oBAAoB,GAA1B,sBAAA;AACA,IAAMC,iBAAiB,GAAvB,mBAAA,C,CAAA;;AAGA,IAAMC,MAAM,GAAZ,QAAA;AACA,IAAMC,IAAI,GAAV,MAAA,C,CAAA;;AAGA,IAAMC,QAAQ,GAAd,UAAA;AAEA,IAAMC,KAAK,GAAX,OAAA;AAEA,IAAMC,gBAAgB,GAAtB,kBAAA;AAEA,IAAMC,iBAAiB,GAAvB,mBAAA,C,CAAA;;AAGA,IAAMC,UAAU,GAAe;AAC7BC,EAAAA,OAAO,EADsB,IAAA;AAE7BC,EAAAA,MAAM,GAAA,OAAA,GAAA,EAAA,EAAA,OAAA,CAAA,IAAA,CAAA,GACI;AACNC,IAAAA,EAAE,GAAA,GAAA,GAAA,EAAA,EAAA,GAAA,CAAA,IAAA,CAAA,GAAA,IAAA,EAAA,GAAA,CAAA,KAAA,CAAA,GAAA,IAAA,EAAA,GAAA,CAAA,MAAA,CAAA,GAAA,UAAA,EAAA,GAAA,CAAA,cAAA,CAAA,GAAA,IAAA,EAAA,GAAA,CAAA,KAAA,CAAA,GAAA,UAAA,EAAA,GAAA,CAAA,QAAA,CAAA,GAAA,UAAA,EAAA,GAAA,CAAA,gBAAA,CAAA,GAAA,UAAA,EAAA,GAAA;AADI,GADJ,EAAA,OAAA,CAAA,UAAA,CAAA,GAYU;AACZA,IAAAA,EAAE,GAAA,IAAA,GAAA,EAAA,EAAA,IAAA,CAAA,MAAA,CAAA,GAAA,UAAA,EAAA,IAAA,CAAA,KAAA,CAAA,GAAA,UAAA,EAAA,IAAA,CAAA,QAAA,CAAA,GAAA,UAAA,EAAA,IAAA,CAAA,KAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,MAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,iBAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,QAAA,CAAA,GAAA,WAAA,EAAA,IAAA,CAAA,iBAAA,CAAA,GAAA,IAAA,EAAA,IAAA;AADU,GAZV,EAAA,OAAA,CAAA,UAAA,CAAA,GAyBU;AACZA,IAAAA,EAAE,GAAA,IAAA,GAAA,EAAA,EAAA,IAAA,CAAA,MAAA,CAAA,GAAA,UAAA,EAAA,IAAA,CAAA,KAAA,CAAA,GAAA,UAAA,EAAA,IAAA,CAAA,KAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,MAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,QAAA,CAAA,GAAA,UAAA,EAAA,IAAA,CAAA,iBAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,oBAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,iBAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,QAAA,CAAA,GAAA,WAAA,EAAA,IAAA;AADU,GAzBV,EAAA,OAAA,CAAA,WAAA,CAAA,GAuCW;AACbA,IAAAA,EAAE,GAAA,IAAA,GAAA,EAAA,EAAA,IAAA,CAAA,KAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,MAAA,CAAA,GAAA,UAAA,EAAA,IAAA,CAAA,KAAA,CAAA,GAAA,UAAA,EAAA,IAAA,CAAA,IAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,MAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,QAAA,CAAA,GAAA,UAAA,EAAA,IAAA,CAAA,iBAAA,CAAA,GAAA,IAAA,EAAA,IAAA,CAAA,iBAAA,CAAA,GAAA,IAAA,EAAA,IAAA;AADW,GAvCX,EAAA,OAAA;AAFuB,CAA/B;;AAwDA,IAAMC,OAAO,GAAY,SAAnBA,OAAmB,CAAA,IAAA,EAAA,KAAA,EAAA;AACvB,MAAMC,SAAS,GAAA,QAAA,CAAA,EAAA,EAAA,IAAA,EAAA;AAAcC,IAAAA,aAAa,EAAEC,KAAK,CAACC;AAAnC,GAAA,CAAf;;AACA,UAAQD,KAAK,CAAb,IAAA;AACE,SAAA,MAAA;AACA,SAAA,cAAA;AACE,aAAA,QAAA,CAAA,EAAA,EAAA,SAAA,EAAA;AAEEE,QAAAA,eAAe,EAFjB,IAAA;AAGEC,QAAAA,KAAK,EAAEH,KAAK,CAACG;AAHf,OAAA,CAAA;;AAKF,SAAA,QAAA;AACA,SAAA,gBAAA;AACE,aAAA,QAAA,CAAA,EAAA,EAAA,SAAA,EAAA;AAEED,QAAAA,eAAe,EAAEE,mBAAmB,CAAA,SAAA,EAAA,KAAA;AAFtC,OAAA,CAAA;;AAIF,SAAA,KAAA;AACE,aAAA,QAAA,CAAA,EAAA,EAAA,SAAA,EAAA;AAEED,QAAAA,KAAK,EAFP,EAAA;AAGED,QAAAA,eAAe,EAAE;AAHnB,OAAA,CAAA;;AAKF,SAAA,IAAA;AACA,SAAA,MAAA;AACE,aAAA,QAAA,CAAA,EAAA,EAAA,SAAA,EAAA;AAEEA,QAAAA,eAAe,EAAE;AAFnB,OAAA,CAAA;;AAIF,SAAA,iBAAA;AACE,aAAA,QAAA,CAAA,EAAA,EAAA,SAAA,EAAA;AAEEC,QAAAA,KAAK,EAAEH,KAAK,CAFd,KAAA;AAGEE,QAAAA,eAAe,EAAE;AAHnB,OAAA,CAAA;;AAKF,SAAA,oBAAA;AACE,aAAA,QAAA,CAAA,EAAA,EAAA,SAAA,EAAA;AAEEC,QAAAA,KAAK,EAAEE,IAAI,CAFb,eAAA;AAGEH,QAAAA,eAAe,EAAE;AAHnB,OAAA,CAAA;;AAKF,SAAA,iBAAA;AACE,aAAA,QAAA,CAAA,EAAA,EAAA,SAAA,EAAA;AAEEA,QAAAA,eAAe,EAAE;AAFnB,OAAA,CAAA;;AAIF,SAAA,QAAA;AACE,aAAA,SAAA;;AACF,SAAA,KAAA;AACE,aAAA,QAAA,CAAA,EAAA,EAAA,SAAA,EAAA;AAEEA,QAAAA,eAAe,EAAEE,mBAAmB,CAAA,SAAA,EAAA,KAAA;AAFtC,OAAA,CAAA;;AAKF;AACE,aAAA,SAAA;AApDJ;AAFF,CAAA;;AA0DA,SAAA,iBAAA,CAAA,KAAA,EAAA;AACE,SAAO,CAAA,UAAA,EAAA,UAAA,EAAA,WAAA,EAAA,QAAA,CAAP,KAAO,CAAP;AACD;AAED;;;;;;;;;AAOA,SAAA,mBAAA,CAAA,SAAA,EAAA,KAAA,EAAA;AACE;AACA,MAAIJ,KAAK,CAAT,KAAA,EAAiB;AACf;AACA,WAAOA,KAAK,CAFG,KAEf,CAFe,CAAA;AAAjB,GAAA,MAIO,IAAIA,KAAK,CAAT,gBAAA,EAA4B;AACjC,WAAOM,SAAS,CAAhB,KAAA;AADK,GAAA,MAEA;AACL,WAAA,IAAA;AACD;AACF;;AAED,IAAMC,yBAAyB,GAAA,aAAGC,uBAAuB,CAAzD,2BAAyD,CAAzD;AAGA,IAAMC,eAAe,GAAA,aAAGC,kBAAkB,CAAA,iBAAA,EAA1C,EAA0C,CAA1C,C,CAAA;AAMA;AACA;;AACA,IAAMC,aAAa,GAAA,aAAGD,kBAAkB,CAAA,eAAA,EAAxC,EAAwC,CAAxC,C,CAAA;;AAOA;;;;;;IAKaE,QAAQ,GAAA,aAAGC,gBAAgB,CACtC,SAAA,QAAA,CAAA,IAAA,EAAA,YAAA,EAAA;MAEIC,QAAAA,GAAAA,IAAAA,CAAAA,Q;8BACAC,W;MAAAA,WAAAA,GAAAA,gBAAAA,KAAAA,KAAAA,CAAAA,GAAc,KAAdA,GAAc,gB;MACdC,QAAAA,GAAAA,IAAAA,CAAAA,Q;qBACAC,E;MAAIC,IAAAA,GAAAA,OAAAA,KAAAA,KAAAA,CAAAA,GAAO,KAAPA,GAAO,O;MACGC,SAAAA,GAAAA,IAAAA,CAAd,YAAcA,C;MACKC,cAAAA,GAAAA,IAAAA,CAAnB,iBAAmBA,C;MAChBC,KAAAA,GAAAA,6BAAAA,CAAAA,IAAAA,EAAAA,CAAAA,UAAAA,EAAAA,aAAAA,EAAAA,UAAAA,EAAAA,IAAAA,EAAAA,YAAAA,EAAAA,iBAAAA,CAAAA,C;;4BAIuBG,kBAAkB,E;MAAzCF,OAAAA,GAAAA,mBAAAA,CAAAA,CAAAA,C;MAASC,UAAAA,GAAAA,mBAAAA,CAAAA,CAAAA,C,CAZhB,CAYgBA;;;AAGd,MAAME,QAAQ,GAAGC,MAAjB,EAAA;AAEA,MAAMC,UAAU,GAAGD,MAAnB,EAAA;AAEA,MAAME,SAAS,GAAGF,MAAlB,EAAA,CAnBF,CAmBE;AAGA;AACA;AACA;AACA;AACA;;AACA,MAAMG,mBAAmB,GAAGH,MAA5B,EAAA;AAEA,MAAMI,mBAAmB,GAAGJ,MAA5B,EAAA;AAEA,MAAMK,WAAW,GAAc;AAC7B;AACA;AACA5B,IAAAA,KAAK,EAHwB,EAAA;AAI7B;AACAD,IAAAA,eAAe,EAAE;AALY,GAA/B;;2BAQkCgC,iBAAiB,CAAA,UAAA,EAAA,OAAA,EAAA,WAAA,C;MAA5CF,KAAAA,GAAAA,kBAAAA,CAAAA,CAAAA,C;MAAO3B,IAAAA,GAAAA,kBAAAA,CAAAA,CAAAA,C;MAAM4B,UAAAA,GAAAA,kBAAAA,CAAAA,CAAAA,C;;AAMpBE,EAAAA,kBAAkB,CAAC9B,IAAI,CAAL,aAAA,EAAlB8B,QAAkB,CAAlBA;AAEA,MAAMC,EAAE,GAAGC,KAAK,CAAChB,KAAK,CAAtB,EAAgB,CAAhB;AACA,MAAMiB,SAAS,GAAGF,EAAE,GAAGG,MAAM,CAAA,SAAA,EAAT,EAAS,CAAT,GAApB,SAAA;AAEA,MAAMC,OAAO,GAAiC;AAC5CrB,IAAAA,SAAS,EADmC,SAAA;AAE5CC,IAAAA,cAAc,EAF8B,cAAA;AAG5CS,IAAAA,mBAAmB,EAHyB,mBAAA;AAI5CD,IAAAA,SAAS,EAJmC,SAAA;AAK5Ca,IAAAA,UAAU,EALkC,EAAA;AAM5CpC,IAAAA,IAAI,EANwC,IAAA;AAO5CoB,IAAAA,QAAQ,EAPoC,QAAA;AAQ5CiB,IAAAA,UAAU,EAAEC,iBAAiB,CARe,KAQf,CARe;AAS5CL,IAAAA,SAAS,EATmC,SAAA;AAU5CxB,IAAAA,QAAQ,EAAEA,QAAQ,IAV0B,IAAA;AAW5CC,IAAAA,WAAW,EAXiC,WAAA;AAY5Ce,IAAAA,mBAAmB,EAZyB,mBAAA;AAa5CH,IAAAA,UAAU,EAbkC,UAAA;AAc5CK,IAAAA,KAAK,EAduC,KAAA;AAe5CC,IAAAA,UAAU,EAAVA;AAf4C,GAA9C;AAkBAW,EAAAA,cAAc,CAAdA,UAAc,CAAdA;AAEA,SACE,aAAA,CAAA,kBAAA,EAAA;AACEJ,IAAAA,OAAO,EAAEjC,yBADX;AAEEsC,IAAAA,KAAK,EAAEvB,OAFT;AAGEwB,IAAAA,GAAG,EAAEvB;AAHP,GAAA,EAKE,aAAA,CAACd,eAAe,CAAhB,QAAA,EAAA;AAA0BN,IAAAA,KAAK,EAAEqC;AAAjC,GAAA,EACE,aAAA,CAAA,IAAA,EAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAUnB,KAAV,EAAUA;2BAA2B,EAA3BA;AAA8B0B,IAAAA,GAAG,EAAEC;AAAnC3B,GAAV,CAAA,EACG,UAAU,CAAV,QAAU,CAAV,GACGL,QAAQ,CAAC;AAAEoB,IAAAA,EAAE,EAAJ,EAAA;AAAMM,IAAAA,UAAU,EAAEC,iBAAiB,CAAA,KAAA;AAAnC,GAAD,CADX,GART,QAOM,CADF,CALF,CADF;AAvEoC,CAAA,C;;AA4HxC,IAAA,OAAA,CAAA,GAAA,CAAA,QAAA,KAAA,YAAA,EAAa;AACX/B,EAAAA,QAAQ,CAARA,WAAAA,GAAAA,UAAAA;AACAA,EAAAA,QAAQ,CAARA,SAAAA,GAAqB;AACnBK,IAAAA,EAAE,EAAEgC,SAAS,CADM,GAAA;AAEnBnC,IAAAA,QAAQ,EAAEmC,SAAS,CAFA,IAAA;AAGnBlC,IAAAA,WAAW,EAAEkC,SAAS,CAACC;AAHJ,GAArBtC;AAKD,C,CAAA;;AAID;;;;;;;;;IAOauC,aAAa,GAAA,aAAGtC,gBAAgB,CAC3C,SAAA,aAAA,CAAA,KAAA,EAAA,YAAA,EAAA;uBAEII,E;MAAIC,IAAAA,GAAAA,QAAAA,KAAAA,KAAAA,CAAAA,GAAO,OAAPA,GAAO,Q;kCACXkC,a;MAAAA,aAAAA,GAAAA,mBAAAA,KAAAA,KAAAA,CAAAA,GAAgB,KAAhBA,GAAgB,mB;iCAChBC,Y;MAAAA,YAAAA,GAAAA,kBAAAA,KAAAA,KAAAA,CAAAA,GAAe,IAAfA,GAAe,kB;MACfC,OAAAA,GAAAA,KAAAA,CAAAA,O;MACAC,QAAAA,GAAAA,KAAAA,CAAAA,Q;MACAC,SAAAA,GAAAA,KAAAA,CAAAA,S;MACAC,MAAAA,GAAAA,KAAAA,CAAAA,M;MACAC,OAAAA,GAAAA,KAAAA,CAAAA,O;MACOC,eAAAA,GAAAA,KAAAA,CAAPxD,K;MACGkB,KAAAA,GAAAA,6BAAAA,CAAAA,KAAAA,EAAAA,CAAAA,IAAAA,EAAAA,eAAAA,EAAAA,cAAAA,EAAAA,SAAAA,EAAAA,UAAAA,EAAAA,WAAAA,EAAAA,QAAAA,EAAAA,SAAAA,EAAAA,OAAAA,CAAAA,C,CAXP,CAeE;;;sBAC0CK,MAAAA,CAAAA,eAAAA,C;MAA3BmC,sBAAAA,GAAAA,aAAAA,CAATD,O;;AACN,MAAIE,yBAAyB,GAAGpC,MAAAA,CAAhC,KAAgCA,CAAhC;AACAqC,EAAAA,eAAe,CAAC,YAAA;AACdD,IAAAA,yBAAyB,CAAzBA,OAAAA,GAAAA,IAAAA;AADa,GAAA,EAEZ,CAFHC,eAEG,CAFY,CAAfA;;0BAeIrC,UAAAA,CAAAA,eAAAA,C;gDAVFrB,I;MAAQH,eAAAA,GAAAA,qBAAAA,CAAAA,e;MAAiBC,KAAAA,GAAAA,qBAAAA,CAAAA,K;MAAOJ,aAAAA,GAAAA,qBAAAA,CAAAA,a;MAChC0B,QAAAA,GAAAA,iBAAAA,CAAAA,Q;MACAO,KAAAA,GAAAA,iBAAAA,CAAAA,K;MACAC,UAAAA,GAAAA,iBAAAA,CAAAA,U;MACAK,SAAAA,GAAAA,iBAAAA,CAAAA,S;MACAT,mBAAAA,GAAAA,iBAAAA,CAAAA,mB;MACAd,WAAAA,GAAAA,iBAAAA,CAAAA,W;MACA2B,UAAAA,GAAAA,iBAAAA,CAAAA,U;MACAvB,SAAAA,GAAAA,iBAAAA,CAAAA,S;MACAC,cAAAA,GAAAA,iBAAAA,CAAAA,c;;AAGF,MAAI2B,GAAG,GAAGiB,YAAY,CAAA,QAAA,EAAtB,YAAsB,CAAtB,CAnCF,CAmCE;AAGA;;AACA,MAAIC,gBAAgB,GAAGvC,MAAAA,CAAvB,KAAuBA,CAAvB;AAEA,MAAIwC,aAAa,GAAGC,UAApB,EAAA;AAEA,MAAIC,UAAU,GAAGC,OAAjB,EAAA;AAEA,MAAIC,YAAY,GAAGX,eAAe,IAAlC,IAAA,CA7CF,CA6CE;AAGA;AACA;;AACAY,EAAAA,yBAAyB,CAAC,YAAA;AACxB1C,IAAAA,mBAAmB,CAAnBA,OAAAA,GAAAA,YAAAA;AADuB,GAAA,EAEtB,CAAA,YAAA,EAFH0C,mBAEG,CAFsB,CAAzBA;AAIA,MAAMC,iBAAiB,GAAG,WAAA,CACxB,UAAA,KAAA,EAAA;AACE,QAAIrE,KAAK,CAALA,IAAAA,OAAJ,EAAA,EAAyB;AACvB8B,MAAAA,UAAU,CAAVA,KAAU,CAAVA;AADF,KAAA,MAEO,IACL9B,KAAK,KAALA,sBAAAA,IACA,CAAC2D,yBAAyB,CAFrB,OAAA,EAGL;AACA7B,MAAAA,UAAU,CAAA,cAAA,EAAiB;AAAE9B,QAAAA,KAAK,EAALA;AAAF,OAAjB,CAAV8B;AAJK,KAAA,MAKA;AACLA,MAAAA,UAAU,CAAA,MAAA,EAAS;AAAE9B,QAAAA,KAAK,EAALA;AAAF,OAAT,CAAV8B;AACD;AAXqB,GAAA,EAaxB,CAAA,sBAAA,EAbF,UAaE,CAbwB,CAA1B;AAgBAP,EAAAA,SAAAA,CAAgB,YAAA;AACd;AACA;AACA;AACA,QACE4C,YAAY,IACZX,eAAe,KADfW,KAAAA,MAAAA;AAGCX,IAAAA,eAAgB,CAAhBA,IAAAA,OAAAA,EAAAA,GAAiC,CAACxD,KAAK,IAAN,EAAA,EAAA,IAAA,OAAjCwD,EAAAA,GAJH,IACEW,CADF,EAKE;AACAE,MAAAA,iBAAiB,CAAjBA,eAAiB,CAAjBA;AACD;AAXH9C,GAAAA,EAYG,CAAA,eAAA,EAAA,iBAAA,EAAA,YAAA,EAZHA,KAYG,CAZHA,CAAAA,CAtEF,CAsEEA;AAeA;AACA;;AACA,WAAA,YAAA,CAAA,KAAA,EAAA;QACUvB,KAAAA,GAAUH,KAAK,CAACyE,MAANzE,CAAVG,K;;AACR,QAAI,CAAJ,YAAA,EAAmB;AACjBqE,MAAAA,iBAAiB,CAAjBA,KAAiB,CAAjBA;AACD;AACF;;AAED,WAAA,WAAA,GAAA;AACE,QAAA,aAAA,EAAmB;AACjBP,MAAAA,gBAAgB,CAAhBA,OAAAA,GAAAA,IAAAA;AACD,KAHH,CAGG;AAGD;AACA;;;AACA,QAAIlD,WAAW,IAAIhB,aAAa,KAAhC,iBAAA,EAAwD;AACtDkC,MAAAA,UAAU,CAAVA,KAAU,CAAVA;AACD;AACF;;AAED,WAAA,WAAA,GAAA;AACE,QAAIgC,gBAAgB,CAApB,OAAA,EAA8B;AAC5BA,MAAAA,gBAAgB,CAAhBA,OAAAA,GAAAA,KAAAA;AACAxC,MAAAA,QAAQ,CAARA,OAAAA,CAAAA,MAAAA;AACD;AACF;;AAED,MAAMiD,UAAU,GACdrB,YAAY,KAAKrB,KAAK,KAALA,UAAAA,IAAwBA,KAAK,KAA9CqB,WAAY,CAAZA,GAAAA;AAEInD,EAAAA,eAAe,IAAfA,eAAAA,IAFJmD,KAAAA,GAGIM,eAAe,IAJrB,KAAA;AAMA,SACE,aAAA,CAAA,IAAA,EAAA,MAAA,CAAA,MAAA,CAAA;6BAEIzD,eAAe,GAAGyE,MAAM,CAACC,QAAQ,CAAlB,eAAkB,CAAT,CAAT,GAAuCC,SAF1D;yBAIoB,MAJpB;qBAKiBvC,SALjB;qBAMiBI,UANjB;qBAOgB,SAPhB;kBAQcvB,SARd;uBASmBA,SAAS,GAAA,SAAA,GAAeC,cAT3C;AAUE0D,IAAAA,IAAI,EAAC;AAVP,GAAA,EAWMzD,KAXN,EAWMA;iCACsB,EADtBA;AAEJ0B,IAAAA,GAAG,EAAEA,GAFD1B;AAGJoC,IAAAA,MAAM,EAAEsB,SAAS,CAAA,MAAA,EAAA,UAAA,CAHb1D;AAIJkC,IAAAA,QAAQ,EAAEwB,SAAS,CAAA,QAAA,EAAA,YAAA,CAJf1D;AAKJiC,IAAAA,OAAO,EAAEyB,SAAS,CAAA,OAAA,EAAA,WAAA,CALd1D;AAMJqC,IAAAA,OAAO,EAAEqB,SAAS,CAAA,OAAA,EAAA,WAAA,CANd1D;AAOJmC,IAAAA,SAAS,EAAEuB,SAAS,CAAA,SAAA,EAAA,aAAA,CAPhB1D;AAQJlB,IAAAA,KAAK,EAAEuE,UAAU,IAAI;AARjBrD,GAXN,CAAA,CADF;AAzHyC,CAAA,C;;AAsL7C,IAAA,OAAA,CAAA,GAAA,CAAA,QAAA,KAAA,YAAA,EAAa;AACX8B,EAAAA,aAAa,CAAbA,WAAAA,GAAAA,eAAAA;AACD,C,CAAA;;AAID;;;;;;;;;;;IASa6B,eAAe,GAAA,aAAGnE,gBAAgB,CAG7C,SAAA,eAAA,CAAA,KAAA,EAAA,YAAA,EAAA;uBAEEI,E;MAAIC,IAAAA,GAAAA,QAAAA,KAAAA,KAAAA,CAAAA,GAAO,KAAPA,GAAO,Q;MACXF,QAAAA,GAAAA,KAAAA,CAAAA,Q;2BACAiE,M;MAAAA,MAAAA,GAAAA,YAAAA,KAAAA,KAAAA,CAAAA,GAAS,IAATA,GAAS,Y;MACTzB,SAAAA,GAAAA,KAAAA,CAAAA,S;MACAC,MAAAA,GAAAA,KAAAA,CAAAA,M;6BACAyB,Q;MAAAA,QAAAA,GAAAA,cAAAA,KAAAA,KAAAA,CAAAA,GAAWC,kBAAXD,GAAWC,c;MACR9D,KAAAA,GAAAA,6BAAAA,CAAAA,KAAAA,EAAAA,CAAAA,IAAAA,EAAAA,UAAAA,EAAAA,QAAAA,EAAAA,WAAAA,EAAAA,QAAAA,EAAAA,UAAAA,CAAAA,C;;2BAIwCK,UAAAA,CAAAA,eAAAA,C;MAArCC,UAAAA,GAAAA,kBAAAA,CAAAA,U;MAAYF,QAAAA,GAAAA,kBAAAA,CAAAA,Q;MAAUiB,UAAAA,GAAAA,kBAAAA,CAAAA,U;;AAG9B,MAAMK,GAAG,GAAGiB,YAAY,CAAA,UAAA,EAAxB,YAAwB,CAAxB;AACA,MAAME,aAAa,GAAGC,UAAtB,EAAA;AACA,MAAMC,UAAU,GAAGC,OAAnB,EAAA;AAEA,MAAMe,WAAW,GAAG;AAClB,mCADkB,EAAA;AAElB5B,IAAAA,SAAS,EAAEuB,SAAS,CAAA,SAAA,EAFF,aAEE,CAFF;AAGlBtB,IAAAA,MAAM,EAAEsB,SAAS,CAAA,MAAA,EAHC,UAGD,CAHC;AAIlB;AACA;AACA;AACA;AACA;AACAM,IAAAA,MAAM,EAAE,CATU,UAAA;AAUlBC,IAAAA,QAAQ,EAAE,CAVQ,CAAA;AAWlBtE,IAAAA,QAAQ,EAARA;AAXkB,GAApB;AAcA,SAAOiE,MAAM,GACX,aAAA,CAAA,OAAA,EAAA,MAAA,CAAA,MAAA,CAAA;AACEhE,IAAAA,EAAE,EAAEC;AADN,GAAA,EAEMG,KAFN,EAEMA;AACJ0B,IAAAA,GAAG,EAAEA,GADD1B;AAEJ6D,IAAAA,QAAQ,EAAEA,QAFN7D;AAGJkE,IAAAA,SAAS,EAAE9D;AAHPJ,GAFN,EADW,WACX,CAAA,CADW,GAUXK,aAAAA,CAAAA,IAAAA,EAAAA,MAAAA,CAAAA,MAAAA,CAAAA;AAAMqB,IAAAA,GAAG,EAAEA;AAAXrB,GAAAA,EAAoBL,KAApBK,EAVF,WAUEA,CAAAA,CAVF;AApC6C,CAAA,C;;AAkD/C,IAAA,OAAA,CAAA,GAAA,CAAA,QAAA,KAAA,YAAA,EAAa;AACXsD,EAAAA,eAAe,CAAfA,WAAAA,GAAAA,iBAAAA;AACD,C,CAAA;;AAmBD;;;;;;;;;;IAQaQ,YAAY,GAAA,aAAG3E,gBAAgB,CAC1C,SAAA,YAAA,CAAA,KAAA,EAAA,YAAA,EAAA;oCAII4E,gB;MAAAA,gBAAAA,GAAAA,qBAAAA,KAAAA,KAAAA,CAAAA,GAAmB,KAAnBA,GAAmB,qB;uBACnBxE,E;MAAIC,IAAAA,GAAAA,QAAAA,KAAAA,KAAAA,CAAAA,GAAO,IAAPA,GAAO,Q;MACRG,KAAAA,GAAAA,6BAAAA,CAAAA,KAAAA,EAAAA,CAAAA,kBAAAA,EAAAA,IAAAA,CAAAA,C;;2BAIsCK,UAAAA,CAAAA,eAAAA,C;MAAnCI,mBAAAA,GAAAA,kBAAAA,CAAAA,mB;MAAqBQ,SAAAA,GAAAA,kBAAAA,CAAAA,S;;AAI7B,MAAA,gBAAA,EAAsB;AACpBR,IAAAA,mBAAmB,CAAnBA,OAAAA,GAAAA,IAAAA;AACD;;AAED,SACE,aAAA,CAAA,IAAA,EAAA,MAAA,CAAA,MAAA,CAAA;AACEgD,IAAAA,IAAI,EAAC;AADP,GAAA,EAEMzD,KAFN,EAEMA;AACJ0B,IAAAA,GAAG,EAAEC,YADD3B;gCAEqB,EAFrBA;AAGJe,IAAAA,EAAE,EAAEE;AAHAjB,GAFN,CAAA,CADF;AAnBwC,CAAA,C;;AAmD5C,IAAA,OAAA,CAAA,GAAA,CAAA,QAAA,KAAA,YAAA,EAAa;AACXmE,EAAAA,YAAY,CAAZA,WAAAA,GAAAA,cAAAA;AACD,C,CAAA;;AAID;;;;;;;;;IAOaE,cAAc,GAAA,aAAG7E,gBAAgB,CAC5C,SAAA,cAAA,CAAA,KAAA,EAAA,YAAA,EAAA;uBACII,E;MAAIC,IAAAA,GAAAA,QAAAA,KAAAA,KAAAA,CAAAA,GAAO,IAAPA,GAAO,Q;MAAMF,QAAAA,GAAAA,KAAAA,CAAAA,Q;MAAUb,KAAAA,GAAAA,KAAAA,CAAAA,K;MAAOmD,OAAAA,GAAAA,KAAAA,CAAAA,O;MAAYjC,KAAAA,GAAAA,6BAAAA,CAAAA,KAAAA,EAAAA,CAAAA,IAAAA,EAAAA,UAAAA,EAAAA,OAAAA,EAAAA,SAAAA,CAAAA,C;;2BAO5CK,UAAAA,CAAAA,eAAAA,C;MAHFZ,QAAAA,GAAAA,kBAAAA,CAAAA,Q;MACQZ,eAAAA,GAAAA,kBAAAA,CAARG,IAAQH,CAAAA,e;MACR+B,UAAAA,GAAAA,kBAAAA,CAAAA,U;;AAGF,MAAI0D,MAAM,GAAGjE,MAAAA,CAAb,IAAaA,CAAb;AACA,MAAIqB,GAAG,GAAGiB,YAAY,CAAA,YAAA,EAAtB,MAAsB,CAAtB;AAEA,MAAI4B,KAAK,GAAGC,aAAa,CACvB;AACEC,IAAAA,OAAO,EAAEH,MAAM,CADjB,OAAA;AAEExF,IAAAA,KAAK,EAALA;AAFF,GADuB,EAAzB,yBAAyB,CAAzB;AAQA,MAAM4F,QAAQ,GAAG7F,eAAe,KAAhC,KAAA;;AAEA,MAAM8F,WAAW,GAAG,SAAdA,WAAc,GAAA;AAClBlF,IAAAA,QAAQ,IAAIA,QAAQ,CAApBA,KAAoB,CAApBA;AACAmB,IAAAA,UAAU,CAAA,iBAAA,EAAoB;AAAE9B,MAAAA,KAAK,EAALA;AAAF,KAApB,CAAV8B;AAFF,GAAA;;AAKA,SACE,aAAA,CAACtB,aAAa,CAAd,QAAA,EAAA;AAAwBR,IAAAA,KAAK,EAAE;AAAEA,MAAAA,KAAK,EAAP,KAAA;AAASyF,MAAAA,KAAK,EAALA;AAAT;AAA/B,GAAA,EACE,aAAA,CAAA,IAAA,EAAA,MAAA,CAAA,MAAA,CAAA;qBACiBG,QADjB;AAEEjB,IAAAA,IAAI,EAAC;AAFP,GAAA,EAGMzD,KAHN,EAGMA;kCACuB,EADvBA;AAEJ0B,IAAAA,GAAG,EAAEA,GAFD1B;AAGJe,IAAAA,EAAE,EAAEuC,MAAM,CAACC,QAAQ,CAAT,KAAS,CAAT,CAHNvD;wBAIc0E,QAAQ,GAAA,EAAA,GAAQlB,SAJ9BxD;AAKJ;AACA;AACA;AACAiE,IAAAA,QAAQ,EAAE,CAAC,CARPjE;AASJiC,IAAAA,OAAO,EAAEyB,SAAS,CAAA,OAAA,EAAA,WAAA,CATd1D;AAUJL,IAAAA,QAAQ,EAAEA,QAAQ,IAAIU,aAAAA,CAAAA,kBAAAA,EAAAA,IAAAA;AAVlBL,GAHN,CAAA,CADF,CADF;AA7B0C,CAAA,C;;AA8E9C,IAAA,OAAA,CAAA,GAAA,CAAA,QAAA,KAAA,YAAA,EAAa;AACXqE,EAAAA,cAAc,CAAdA,WAAAA,GAAAA,gBAAAA;AACD,C,CAAA;;AAID;;;;;;;;;;;;;;;;;;SAgBgBO,kB,GAAAA;2BACIvE,UAAAA,CAAAA,aAAAA,C;MAAVvB,KAAAA,GAAAA,kBAAAA,CAAAA,K;;2BAGJuB,UAAAA,CAAAA,eAAAA,C;MADawE,YAAAA,GAAAA,kBAAAA,CAAf7F,IAAe6F,CAAP/F,K;;AAGV,MAAMgG,OAAO,GAAG,OAAA,CACd,YAAA;AAAA,WACEC,OAAO,CAAC;AACNC,MAAAA,WAAW,EAAEC,YAAY,CAACJ,YAAY,IAAzBI,EAAY,CAAZA,CAAAA,KAAAA,CADP,KACOA,CADP;AAENC,MAAAA,eAAe,EAAEpG;AAFX,KAAD,CADT;AADc,GAAA,EAMd,CAAA,YAAA,EANF,KAME,CANc,CAAhB;AASA,SACEuB,aAAAA,CAAAA,QAAAA,EAAAA,IAAAA,EACG,OAAO,CAAP,MAAA,GACG,OAAO,CAAP,GAAA,CAAY,UAAA,MAAA,EAAA,KAAA,EAAA;AACV,QAAM8E,GAAG,GAAGrG,KAAK,CAALA,KAAAA,CAAYsG,MAAM,CAAlBtG,KAAAA,EAA0BsG,MAAM,CAA5C,GAAYtG,CAAZ;AACA,WACE,aAAA,CAAA,MAAA,EAAA;AACEuG,MAAAA,GAAG,EAAEd,KADP;yBAEmBa,MAAM,CAANA,SAAAA,GAAAA,IAAAA,GAA0B5B,SAF7C;8BAGwB4B,MAAM,CAANA,SAAAA,GAAAA,SAAAA,GAA+B;AAHvD,KAAA,EADF,GACE,CADF;AAHL,GACG,CADH,GAFL,KACE/E,CADF;AAkBD;;AAED,IAAA,OAAA,CAAA,GAAA,CAAA,QAAA,KAAA,YAAA,EAAa;AACXuE,EAAAA,kBAAkB,CAAlBA,WAAAA,GAAAA,oBAAAA;AACD,C,CAAA;;AAID;;;;;IAGaU,cAAc,GAAA,aAAG9F,gBAAgB,CAC5C,SAAA,cAAA,CAAA,KAAA,EAAA,YAAA,EAAA;uBACII,E;MAAIC,IAAAA,GAAAA,QAAAA,KAAAA,KAAAA,CAAAA,GAAO,QAAPA,GAAO,Q;MAAUoC,OAAAA,GAAAA,KAAAA,CAAAA,O;MAASE,SAAAA,GAAAA,KAAAA,CAAAA,S;MAAcnC,KAAAA,GAAAA,6BAAAA,CAAAA,KAAAA,EAAAA,CAAAA,IAAAA,EAAAA,SAAAA,EAAAA,WAAAA,CAAAA,C;;2BAS1CK,UAAAA,CAAAA,eAAAA,C;MALFO,UAAAA,GAAAA,kBAAAA,CAAAA,U;MACAD,KAAAA,GAAAA,kBAAAA,CAAAA,K;MACAJ,SAAAA,GAAAA,kBAAAA,CAAAA,S;MACAU,SAAAA,GAAAA,kBAAAA,CAAAA,S;MACAI,UAAAA,GAAAA,kBAAAA,CAAAA,U;;AAEF,MAAMK,GAAG,GAAGiB,YAAY,CAAA,SAAA,EAAxB,YAAwB,CAAxB;AAEA,MAAME,aAAa,GAAGC,UAAtB,EAAA;;AAEA,MAAM6B,WAAW,GAAG,SAAdA,WAAc,GAAA;AAClB,QAAIhE,KAAK,KAAT,IAAA,EAAoB;AAClBC,MAAAA,UAAU,CAAVA,gBAAU,CAAVA;AADF,KAAA,MAEO;AACLA,MAAAA,UAAU,CAAVA,iBAAU,CAAVA;AACD;AALH,GAAA;;AAQA,SACE,aAAA,CAAA,IAAA,EAAA,MAAA,CAAA,MAAA,CAAA;qBACiBK,SADjB;qBAEgB,SAFhB;qBAGiBI;AAHjB,GAAA,EAIMrB,KAJN,EAIMA;kCACuB,EADvBA;AAEJ0B,IAAAA,GAAG,EAAEA,GAFD1B;AAGJiC,IAAAA,OAAO,EAAEyB,SAAS,CAAA,OAAA,EAAA,WAAA,CAHd1D;AAIJmC,IAAAA,SAAS,EAAEuB,SAAS,CAAA,SAAA,EAAA,aAAA;AAJhB1D,GAJN,CAAA,CADF;AAxB0C,CAAA,C;;AAyC9C,IAAA,OAAA,CAAA,GAAA,CAAA,QAAA,KAAA,YAAA,EAAa;AACXsF,EAAAA,cAAc,CAAdA,WAAAA,GAAAA,gBAAAA;AACD,C,CAAA;;AAID;;;;;;;;;;AAQA,SAAA,kBAAA,CAAA,aAAA,EAAA,QAAA,EAAA;AAIE;AACA;AACA;AACA;AACApC,EAAAA,yBAAyB,CAAC,YAAA;AACxB,QACExE,aAAa,KAAbA,QAAAA,IACAA,aAAa,KADbA,MAAAA,IAEAA,aAAa,KAFbA,iBAAAA,IAGAA,aAAa,KAJf,gBAAA,EAKE;AACA0B,MAAAA,QAAQ,CAARA,OAAAA,CAAAA,KAAAA;AACD;AARsB,GAAA,EAStB,CAAA,QAAA,EATH8C,aASG,CATsB,CAAzBA;AAUD;AAED;;;;;;AAIA,SAAA,UAAA,GAAA;2BAQM7C,UAAAA,CAAAA,eAAAA,C;MANMxB,eAAAA,GAAAA,kBAAAA,CAARG,IAAQH,CAAAA,e;MACRY,QAAAA,GAAAA,kBAAAA,CAAAA,Q;MACAkB,KAAAA,GAAAA,kBAAAA,CAAAA,K;MACAC,UAAAA,GAAAA,kBAAAA,CAAAA,U;MACAJ,mBAAAA,GAAAA,kBAAAA,CAAAA,mB;MACAC,mBAAAA,GAAAA,kBAAAA,CAAAA,mB;;AAGF,MAAMR,OAAO,GAAGsF,cAAc,CAA9B,yBAA8B,CAA9B;AAEA,SAAO,SAAA,aAAA,CAAA,KAAA,EAAA;AACL,QAAIhB,KAAK,GAAG,OAAO,CAAP,SAAA,CAAkB,UAAA,KAAA,EAAA;AAAA,UAAGzF,KAAH,GAAA,KAAA,CAAA,KAAA;AAAA,aAAeA,KAAK,KAApB,eAAA;AAA9B,KAAY,CAAZ;;AAEA,aAAA,aAAA,GAAA;AACE,UAAI0G,QAAQ,GAAGjB,KAAK,KAAKtE,OAAO,CAAPA,MAAAA,GAAzB,CAAA;;AACA,UAAA,QAAA,EAAc;AACZ,YAAIO,mBAAmB,CAAvB,OAAA,EAAiC;AAC/B;AACA;AACA;AACA,iBAAA,IAAA;AAJF,SAAA,MAKO;AACL;AACA,iBAAOiF,cAAP,EAAA;AACD;AATH,OAAA,MAUO;AACL;AACA,eAAOxF,OAAO,CAAC,CAACsE,KAAK,GAAN,CAAA,IAActE,OAAO,CAApC,MAAc,CAAd;AACD;AACF;;AAED,aAAA,iBAAA,GAAA;AACE,UAAIyF,KAAK,GAAGnB,KAAK,KAAjB,CAAA;;AACA,UAAA,KAAA,EAAW;AACT,YAAI/D,mBAAmB,CAAvB,OAAA,EAAiC;AAC/B;AACA;AACA;AACA,iBAAA,IAAA;AAJF,SAAA,MAKO;AACL;AACA,iBAAOmF,aAAP,EAAA;AACD;AATH,OAAA,MAUO,IAAIpB,KAAK,KAAK,CAAd,CAAA,EAAkB;AACvB;AACA,eAAOoB,aAAP,EAAA;AAFK,OAAA,MAGA;AACL;AACA,eAAO1F,OAAO,CAAC,CAACsE,KAAK,GAALA,CAAAA,GAAYtE,OAAO,CAApB,MAAA,IAA+BA,OAAO,CAArD,MAAc,CAAd;AACD;AACF;;AAED,aAAA,cAAA,GAAA;AACE,aAAOA,OAAO,CAAd,CAAc,CAAd;AACD;;AAED,aAAA,aAAA,GAAA;AACE,aAAOA,OAAO,CAACA,OAAO,CAAPA,MAAAA,GAAf,CAAc,CAAd;AACD;;AAED,YAAQtB,KAAK,CAAb,GAAA;AACE,WAAA,WAAA;AACE;AACAA,QAAAA,KAAK,CAALA,cAAAA;;AACA,YAAI,CAAA,OAAA,IAAY,CAACsB,OAAO,CAAxB,MAAA,EAAiC;AAC/B;AACD;;AAED,YAAIU,KAAK,KAAT,IAAA,EAAoB;AAClB;AACAC,UAAAA,UAAU,CAAA,QAAA,EAAW;AACnBwD,YAAAA,gBAAgB,EAAE3D,mBAAmB,CAAC8B;AADnB,WAAX,CAAV3B;AAFF,SAAA,MAKO;AACL,cAAIgF,IAAI,GAAGC,aAAX,EAAA;AACAjF,UAAAA,UAAU,CAAA,QAAA,EAAW;AAAE9B,YAAAA,KAAK,EAAE8G,IAAI,GAAGA,IAAI,CAAP,KAAA,GAAgB;AAA7B,WAAX,CAAVhF;AACD;;AACD;AAEF;;AACA,WAAA,SAAA;AACE;AACAjC,QAAAA,KAAK,CAALA,cAAAA;;AACA,YAAI,CAAA,OAAA,IAAYsB,OAAO,CAAPA,MAAAA,KAAhB,CAAA,EAAsC;AACpC;AACD;;AAED,YAAIU,KAAK,KAAT,IAAA,EAAoB;AAClBC,UAAAA,UAAU,CAAVA,QAAU,CAAVA;AADF,SAAA,MAEO;AACL,cAAIkF,IAAI,GAAGC,iBAAX,EAAA;AACAnF,UAAAA,UAAU,CAAA,QAAA,EAAW;AAAE9B,YAAAA,KAAK,EAAEgH,IAAI,GAAGA,IAAI,CAAP,KAAA,GAAgB;AAA7B,WAAX,CAAVlF;AACD;;AACD;;AAEF,WAAA,MAAA;AACA,WAAA,QAAA;AACE;AACAjC,QAAAA,KAAK,CAALA,cAAAA;;AACA,YAAI,CAAA,OAAA,IAAYsB,OAAO,CAAPA,MAAAA,KAAhB,CAAA,EAAsC;AACpC;AACD;;AAED,YAAIU,KAAK,KAAT,IAAA,EAAoB;AAClBC,UAAAA,UAAU,CAAVA,QAAU,CAAVA;AADF,SAAA,MAEO;AACLA,UAAAA,UAAU,CAAA,QAAA,EAAW;AAAE9B,YAAAA,KAAK,EAAE2G,cAAc,GAAG3G;AAA1B,WAAX,CAAV8B;AACD;;AACD;;AAEF,WAAA,KAAA;AACA,WAAA,UAAA;AACE;AACAjC,QAAAA,KAAK,CAALA,cAAAA;;AACA,YAAI,CAAA,OAAA,IAAYsB,OAAO,CAAPA,MAAAA,KAAhB,CAAA,EAAsC;AACpC;AACD;;AAED,YAAIU,KAAK,KAAT,IAAA,EAAoB;AAClBC,UAAAA,UAAU,CAAVA,QAAU,CAAVA;AADF,SAAA,MAEO;AACLA,UAAAA,UAAU,CAAA,QAAA,EAAW;AAAE9B,YAAAA,KAAK,EAAE6G,aAAa,GAAG7G;AAAzB,WAAX,CAAV8B;AACD;;AACD;;AAEF,WAAA,QAAA;AACE,YAAID,KAAK,KAAT,IAAA,EAAoB;AAClBC,UAAAA,UAAU,CAAVA,MAAU,CAAVA;AACD;;AACD;;AACF,WAAA,OAAA;AACE,YAAID,KAAK,KAALA,UAAAA,IAAwB9B,eAAe,KAA3C,IAAA,EAAsD;AACpD;AACAF,UAAAA,KAAK,CAALA,cAAAA;AACAc,UAAAA,QAAQ,IAAIA,QAAQ,CAApBA,eAAoB,CAApBA;AACAmB,UAAAA,UAAU,CAAVA,oBAAU,CAAVA;AACD;;AACD;AA7EJ;AAlDF,GAAA;AAkID;;AAED,SAAA,OAAA,GAAA;2BAOMP,UAAAA,CAAAA,eAAAA,C;MALFM,KAAAA,GAAAA,kBAAAA,CAAAA,K;MACAC,UAAAA,GAAAA,kBAAAA,CAAAA,U;MACAN,UAAAA,GAAAA,kBAAAA,CAAAA,U;MACAF,QAAAA,GAAAA,kBAAAA,CAAAA,Q;MACAG,SAAAA,GAAAA,kBAAAA,CAAAA,S;;AAEF,MAAMyF,MAAM,GAAGC,UAAU,CAAC,YAAA;AAAA,WAAM,IAAN,GAAM,EAAN;AAA1B,GAAyB,CAAzB;AAEA5F,EAAAA,SAAAA,CAAgB,YAAA;AACd,WAAO,YAAA;AACL;AACA2F,MAAAA,MAAM,CAANA,OAAAA,CAAAA,OAAAA,CAAuB,UAAA,EAAA,EAAA;AAAA,eAAQE,oBAAoB,CAA5B,EAA4B,CAA5B;AAAvBF,OAAAA;AAFF,KAAA;AADF3F,GAAAA,EAKG,CALHA,MAKG,CALHA,CAAAA;AAOA,SAAO,SAAA,UAAA,GAAA;AACL,QAAM8F,aAAa,GAAGC,gBAAgB,CAAC9F,UAAU,CAAjD,OAAsC,CAAtC;;AACA,QAAI,CAAJ,aAAA,EAAoB;AAClB;AACD;;AAED,QAAI+F,KAAK,GAAGC,qBAAqB,CAAC,YAAA;AAChC;AACA,UACEH,aAAa,CAAbA,aAAAA,KAAgC/F,QAAQ,CAAxC+F,OAAAA,IACAA,aAAa,CAAbA,aAAAA,KAAgC5F,SAAS,CADzC4F,OAAAA,IAEA7F,UAAU,CAHZ,OAAA,EAIE;AACA,YAAIA,UAAU,CAAVA,OAAAA,CAAAA,QAAAA,CAA4B6F,aAAa,CAA7C,aAAI7F,CAAJ,EAA8D;AAC5D;AACA,cAAIK,KAAK,KAAT,WAAA,EAA2B;AACzBC,YAAAA,UAAU,CAAVA,QAAU,CAAVA;AACD;AAJH,SAAA,MAKO;AACL;AACAA,UAAAA,UAAU,CAAVA,IAAU,CAAVA;AACD;AACF;AAhBH,KAAiC,CAAjC;AAkBAoF,IAAAA,MAAM,CAANA,OAAAA,CAAAA,GAAAA,CAAAA,KAAAA;AAxBF,GAAA;AA0BD;AAED;;;;;;;;;;AAQA,SAAA,iBAAA,CAAA,KAAA,EAAA,OAAA,EAAA,WAAA,EAAA;wBAK4B3F,QAAAA,CAAemG,KAAK,CAApBnG,OAAAA,C;MAAnBM,KAAAA,GAAAA,eAAAA,CAAAA,CAAAA,C;MAAO4F,QAAAA,GAAAA,eAAAA,CAAAA,CAAAA,C;;0BACWlG,UAAAA,CAAAA,OAAAA,EAAAA,WAAAA,C;MAAlBrB,IAAAA,GAAAA,iBAAAA,CAAAA,CAAAA,C;MAAMyH,QAAAA,GAAAA,iBAAAA,CAAAA,CAAAA,C;;AAEb,MAAM7F,UAAU,GAAe,SAAzBA,UAAyB,CAAA,KAAA,EAAA,OAAA,EAAA;QAAQ8F,OAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,OAAAA,GAAU,EAAVA;;;AACrC,QAAMC,YAAY,GAAGH,KAAK,CAALA,MAAAA,CAArB,KAAqBA,CAArB;AACA,QAAM/H,SAAS,GAAGkI,YAAY,IAAIA,YAAY,CAAZA,EAAAA,CAAlC,KAAkCA,CAAlC;;AACA,QAAA,SAAA,EAAe;AACbF,MAAAA,QAAQ,CAAA,QAAA,CAAA;AAAG7H,QAAAA,IAAI,EAAP,KAAA;AAAgB+B,QAAAA,KAAK,EAArB,KAAA;AAAuBlC,QAAAA,SAAS,EAAEkC;AAAlC,OAAA,EAAR8F,OAAQ,CAAA,CAARA;AACAF,MAAAA,QAAQ,CAARA,SAAQ,CAARA;AACA;AACD;AAPH,GAAA;;AAUA,SAAO,CAAA,KAAA,EAAA,IAAA,EAAP,UAAO,CAAP;AACD;AAED;;;;;;;;;;;;;AAWA,IAAMhD,QAAQ,GAAG,SAAXA,QAAW,CAAA,GAAA,EAAA;AACf,MAAIqD,IAAI,GAAR,CAAA;;AACA,MAAIzB,GAAG,CAAHA,MAAAA,KAAJ,CAAA,EAAsB;AACpB,WAAA,IAAA;AACD;;AACD,OAAK,IAAI0B,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAG1B,GAAG,CAAvB,MAAA,EAAgC0B,CAAhC,EAAA,EAAqC;AACnC,QAAIC,KAAI,GAAG3B,GAAG,CAAHA,UAAAA,CAAX,CAAWA,CAAX;;AACAyB,IAAAA,IAAI,GAAG,CAACA,IAAI,IAAL,CAAA,IAAA,IAAA,GAAPA,KAAAA;AACAA,IAAAA,IAAI,GAAGA,IAAI,GAAXA,IAAAA;AACD;;AACD,SAAA,IAAA;AAVF,CAAA;AAaA;;;;;;;;SAOgB3B,Y,CAAaE,G,EAAAA;AAC3B,SAAO7B,MAAM,CAANA,GAAM,CAANA,CAAAA,OAAAA,CAAAA,2BAAAA,EAAP,MAAOA,CAAP;AACD,C,CAAA;;AAID;;;;;;;SAKgByD,kB,GAAAA;4BACmB1G,UAAAA,CAAAA,eAAAA,C;MAA3BgB,UAAAA,GAAAA,mBAAAA,CAAAA,U;MAAYD,UAAAA,GAAAA,mBAAAA,CAAAA,U;;AAClB,SAAO,OAAA,CACL,YAAA;AAAA,WAAO;AACLL,MAAAA,EAAE,EADG,UAAA;AAELM,MAAAA,UAAU,EAAVA;AAFK,KAAP;AADK,GAAA,EAKL,CAAA,UAAA,EALF,UAKE,CALK,CAAP;AAOD","sourcesContent":["/**\n * Welcome to @reach/combobox!\n *\n * Accessible combobox (autocomplete or autosuggest) component for React.\n *\n * A combobox is the combination of an `<input type=\"text\"/>` and a list. The\n * list is designed to help the user arrive at a value, but the value does not\n * necessarily have to come from that list. Don't think of it like a\n * `<select/>`, but more of an `<input type=\"text\"/>` with some suggestions. You\n * can, however, validate that the value comes from the list, that's up to your\n * app.\n *\n * ???: navigate w/ arrows, then hit backspace: should it delete the\n *      autocompleted text or the old value the user had typed?!\n *\n * @see Docs     https://reach.tech/combobox\n * @see Source   https://github.com/reach/reach-ui/tree/main/packages/combobox\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#combobox\n */\n\nimport * as React from \"react\";\nimport PropTypes from \"prop-types\";\nimport {\n  createNamedContext,\n  forwardRefWithAs,\n  getOwnerDocument,\n  isFunction,\n  makeId,\n  noop,\n  useCheckStyles,\n  useForkedRef,\n  useIsomorphicLayoutEffect,\n  useLazyRef,\n  useUpdateEffect,\n  wrapEvent,\n} from \"@reach/utils\";\nimport {\n  createDescendantContext,\n  DescendantProvider,\n  useDescendant,\n  useDescendants,\n  useDescendantsInit,\n} from \"@reach/descendants\";\nimport { findAll } from \"highlight-words-core\";\nimport { useId } from \"@reach/auto-id\";\nimport { Popover, positionMatchWidth } from \"@reach/popover\";\n\nimport type { PopoverProps } from \"@reach/popover\";\nimport type { Descendant } from \"@reach/descendants\";\n\n////////////////////////////////////////////////////////////////////////////////\n// States\n\n// Nothing going on, waiting for the user to type or use the arrow keys\nconst IDLE = \"IDLE\";\n\n// The component is suggesting options as the user types\nconst SUGGESTING = \"SUGGESTING\";\n\n// The user is using the keyboard to navigate the list, not typing\nconst NAVIGATING = \"NAVIGATING\";\n\n// The user is interacting with arbitrary elements inside the popup that\n// are not ComboboxInputs\nconst INTERACTING = \"INTERACTING\";\n\n////////////////////////////////////////////////////////////////////////////////\n// Events\n\n// User cleared the value w/ backspace, but input still has focus\nconst CLEAR = \"CLEAR\";\n\n// User is typing\nconst CHANGE = \"CHANGE\";\n\n// Initial input value change handler for syncing user state with state machine\n// Prevents initial change from sending the user to the NAVIGATING state\n// https://github.com/reach/reach-ui/issues/464\nconst INITIAL_CHANGE = \"INITIAL_CHANGE\";\n\n// User is navigating w/ the keyboard\nconst NAVIGATE = \"NAVIGATE\";\n\n// User can be navigating with keyboard and then click instead, we want the\n// value from the click, not the current nav item\nconst SELECT_WITH_KEYBOARD = \"SELECT_WITH_KEYBOARD\";\nconst SELECT_WITH_CLICK = \"SELECT_WITH_CLICK\";\n\n// Pretty self-explanatory, user can hit escape or blur to close the popover\nconst ESCAPE = \"ESCAPE\";\nconst BLUR = \"BLUR\";\n\n// The user left the input to interact with arbitrary elements inside the popup\nconst INTERACT = \"INTERACT\";\n\nconst FOCUS = \"FOCUS\";\n\nconst OPEN_WITH_BUTTON = \"OPEN_WITH_BUTTON\";\n\nconst CLOSE_WITH_BUTTON = \"CLOSE_WITH_BUTTON\";\n\n////////////////////////////////////////////////////////////////////////////////\nconst stateChart: StateChart = {\n  initial: IDLE,\n  states: {\n    [IDLE]: {\n      on: {\n        [BLUR]: IDLE,\n        [CLEAR]: IDLE,\n        [CHANGE]: SUGGESTING,\n        [INITIAL_CHANGE]: IDLE,\n        [FOCUS]: SUGGESTING,\n        [NAVIGATE]: NAVIGATING,\n        [OPEN_WITH_BUTTON]: SUGGESTING,\n      },\n    },\n    [SUGGESTING]: {\n      on: {\n        [CHANGE]: SUGGESTING,\n        [FOCUS]: SUGGESTING,\n        [NAVIGATE]: NAVIGATING,\n        [CLEAR]: IDLE,\n        [ESCAPE]: IDLE,\n        [BLUR]: IDLE,\n        [SELECT_WITH_CLICK]: IDLE,\n        [INTERACT]: INTERACTING,\n        [CLOSE_WITH_BUTTON]: IDLE,\n      },\n    },\n    [NAVIGATING]: {\n      on: {\n        [CHANGE]: SUGGESTING,\n        [FOCUS]: SUGGESTING,\n        [CLEAR]: IDLE,\n        [BLUR]: IDLE,\n        [ESCAPE]: IDLE,\n        [NAVIGATE]: NAVIGATING,\n        [SELECT_WITH_CLICK]: IDLE,\n        [SELECT_WITH_KEYBOARD]: IDLE,\n        [CLOSE_WITH_BUTTON]: IDLE,\n        [INTERACT]: INTERACTING,\n      },\n    },\n    [INTERACTING]: {\n      on: {\n        [CLEAR]: IDLE,\n        [CHANGE]: SUGGESTING,\n        [FOCUS]: SUGGESTING,\n        [BLUR]: IDLE,\n        [ESCAPE]: IDLE,\n        [NAVIGATE]: NAVIGATING,\n        [CLOSE_WITH_BUTTON]: IDLE,\n        [SELECT_WITH_CLICK]: IDLE,\n      },\n    },\n  },\n};\n\nconst reducer: Reducer = (data: StateData, event: MachineEvent) => {\n  const nextState = { ...data, lastEventType: event.type };\n  switch (event.type) {\n    case CHANGE:\n    case INITIAL_CHANGE:\n      return {\n        ...nextState,\n        navigationValue: null,\n        value: event.value,\n      };\n    case NAVIGATE:\n    case OPEN_WITH_BUTTON:\n      return {\n        ...nextState,\n        navigationValue: findNavigationValue(nextState, event),\n      };\n    case CLEAR:\n      return {\n        ...nextState,\n        value: \"\",\n        navigationValue: null,\n      };\n    case BLUR:\n    case ESCAPE:\n      return {\n        ...nextState,\n        navigationValue: null,\n      };\n    case SELECT_WITH_CLICK:\n      return {\n        ...nextState,\n        value: event.value,\n        navigationValue: null,\n      };\n    case SELECT_WITH_KEYBOARD:\n      return {\n        ...nextState,\n        value: data.navigationValue,\n        navigationValue: null,\n      };\n    case CLOSE_WITH_BUTTON:\n      return {\n        ...nextState,\n        navigationValue: null,\n      };\n    case INTERACT:\n      return nextState;\n    case FOCUS:\n      return {\n        ...nextState,\n        navigationValue: findNavigationValue(nextState, event),\n      };\n\n    default:\n      return nextState;\n  }\n};\n\nfunction popoverIsExpanded(state: State) {\n  return [SUGGESTING, NAVIGATING, INTERACTING].includes(state);\n}\n\n/**\n * When we open a list, set the navigation value to the value in the input, if\n * it's in the list, then it'll automatically be highlighted.\n *\n * @param stateData\n * @param event\n */\nfunction findNavigationValue(stateData: StateData, event: MachineEvent) {\n  // @ts-ignore\n  if (event.value) {\n    // @ts-ignore\n    return event.value;\n    // @ts-ignore\n  } else if (event.persistSelection) {\n    return stateData.value;\n  } else {\n    return null;\n  }\n}\n\nconst ComboboxDescendantContext = createDescendantContext<ComboboxDescendant>(\n  \"ComboboxDescendantContext\"\n);\nconst ComboboxContext = createNamedContext(\n  \"ComboboxContext\",\n  {} as InternalComboboxContextValue\n);\n\n// Allows us to put the option's value on context so that ComboboxOptionText\n// can work it's highlight text magic no matter what else is rendered around\n// it.\nconst OptionContext = createNamedContext(\n  \"OptionContext\",\n  {} as ComboboxOptionContextValue\n);\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Combobox\n *\n * @see Docs https://reach.tech/combobox#combobox\n */\nexport const Combobox = forwardRefWithAs<ComboboxProps, \"div\">(\n  function Combobox(\n    {\n      onSelect,\n      openOnFocus = false,\n      children,\n      as: Comp = \"div\",\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledby,\n      ...props\n    },\n    forwardedRef\n  ) {\n    let [options, setOptions] = useDescendantsInit<ComboboxDescendant>();\n\n    // Need this to focus it\n    const inputRef = React.useRef();\n\n    const popoverRef = React.useRef();\n\n    const buttonRef = React.useRef();\n\n    // When <ComboboxInput autocomplete={false} /> we don't want cycle back to\n    // the user's value while navigating (because it's always the user's value),\n    // but we need to know this in useKeyDown which is far away from the prop\n    // here, so we do something sneaky and write it to this ref on context so we\n    // can use it anywhere else 😛. Another new trick for me and I'm excited\n    // about this one too!\n    const autocompletePropRef = React.useRef();\n\n    const persistSelectionRef = React.useRef();\n\n    const defaultData: StateData = {\n      // The value the user has typed. We derive this also when the developer is\n      // controlling the value of ComboboxInput.\n      value: \"\",\n      // the value the user has navigated to with the keyboard\n      navigationValue: null,\n    };\n\n    const [state, data, transition] = useReducerMachine(\n      stateChart,\n      reducer,\n      defaultData\n    );\n\n    useFocusManagement(data.lastEventType, inputRef);\n\n    const id = useId(props.id);\n    const listboxId = id ? makeId(\"listbox\", id) : \"listbox\";\n\n    const context: InternalComboboxContextValue = {\n      ariaLabel,\n      ariaLabelledby,\n      autocompletePropRef,\n      buttonRef,\n      comboboxId: id,\n      data,\n      inputRef,\n      isExpanded: popoverIsExpanded(state),\n      listboxId,\n      onSelect: onSelect || noop,\n      openOnFocus,\n      persistSelectionRef,\n      popoverRef,\n      state,\n      transition,\n    };\n\n    useCheckStyles(\"combobox\");\n\n    return (\n      <DescendantProvider\n        context={ComboboxDescendantContext}\n        items={options}\n        set={setOptions}\n      >\n        <ComboboxContext.Provider value={context}>\n          <Comp {...props} data-reach-combobox=\"\" ref={forwardedRef}>\n            {isFunction(children)\n              ? children({ id, isExpanded: popoverIsExpanded(state) })\n              : children}\n          </Comp>\n        </ComboboxContext.Provider>\n      </DescendantProvider>\n    );\n  }\n);\n\n/**\n * @see Docs https://reach.tech/combobox#combobox-props\n */\nexport type ComboboxProps = {\n  /**\n   * @see Docs https://reach.tech/combobox#combobox-children\n   */\n  children:\n    | React.ReactNode\n    | ((props: ComboboxContextValue) => React.ReactNode);\n  /**\n   * Called with the selection value when the user makes a selection from the\n   * list.\n   *\n   * @see Docs https://reach.tech/combobox#combobox-onselect\n   */\n  onSelect?(value: ComboboxValue): void;\n  /**\n   * If true, the popover opens when focus is on the text box.\n   *\n   * @see Docs https://reach.tech/combobox#combobox-openonfocus\n   */\n  openOnFocus?: boolean;\n  /**\n   * Defines a string value that labels the current element.\n   * @see Docs https://reach.tech/combobox#accessibility\n   */\n  \"aria-label\"?: string;\n  /**\n   * Identifies the element (or elements) that labels the current element.\n   * @see Docs https://reach.tech/combobox#accessibility\n   */\n  \"aria-labelledby\"?: string;\n};\n\nif (__DEV__) {\n  Combobox.displayName = \"Combobox\";\n  Combobox.propTypes = {\n    as: PropTypes.any,\n    onSelect: PropTypes.func,\n    openOnFocus: PropTypes.bool,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxInput\n *\n * Wraps an `<input/>` with a couple extra props that work with the combobox.\n *\n * @see Docs https://reach.tech/combobox#comboboxinput\n */\nexport const ComboboxInput = forwardRefWithAs<ComboboxInputProps, \"input\">(\n  function ComboboxInput(\n    {\n      as: Comp = \"input\",\n      selectOnClick = false,\n      autocomplete = true,\n      onClick,\n      onChange,\n      onKeyDown,\n      onBlur,\n      onFocus,\n      value: controlledValue,\n      ...props\n    },\n    forwardedRef\n  ) {\n    // https://github.com/reach/reach-ui/issues/464\n    let { current: initialControlledValue } = React.useRef(controlledValue);\n    let controlledValueChangedRef = React.useRef(false);\n    useUpdateEffect(() => {\n      controlledValueChangedRef.current = true;\n    }, [controlledValue]);\n\n    let {\n      data: { navigationValue, value, lastEventType },\n      inputRef,\n      state,\n      transition,\n      listboxId,\n      autocompletePropRef,\n      openOnFocus,\n      isExpanded,\n      ariaLabel,\n      ariaLabelledby,\n    } = React.useContext(ComboboxContext);\n\n    let ref = useForkedRef(inputRef, forwardedRef);\n\n    // Because we close the List on blur, we need to track if the blur is\n    // caused by clicking inside the list, and if so, don't close the List.\n    let selectOnClickRef = React.useRef(false);\n\n    let handleKeyDown = useKeyDown();\n\n    let handleBlur = useBlur();\n\n    let isControlled = controlledValue != null;\n\n    // Layout effect should be SSR-safe here because we don't actually do\n    // anything with this ref that involves rendering until after we've\n    // let the client hydrate in nested components.\n    useIsomorphicLayoutEffect(() => {\n      autocompletePropRef.current = autocomplete;\n    }, [autocomplete, autocompletePropRef]);\n\n    const handleValueChange = React.useCallback(\n      (value: ComboboxValue) => {\n        if (value.trim() === \"\") {\n          transition(CLEAR);\n        } else if (\n          value === initialControlledValue &&\n          !controlledValueChangedRef.current\n        ) {\n          transition(INITIAL_CHANGE, { value });\n        } else {\n          transition(CHANGE, { value });\n        }\n      },\n      [initialControlledValue, transition]\n    );\n\n    React.useEffect(() => {\n      // If they are controlling the value we still need to do our transitions,\n      // so  we have this derived state to emulate onChange of the input as we\n      // receive new `value`s ...[*]\n      if (\n        isControlled &&\n        controlledValue !== value &&\n        // https://github.com/reach/reach-ui/issues/481\n        (controlledValue!.trim() === \"\" ? (value || \"\").trim() !== \"\" : true)\n      ) {\n        handleValueChange(controlledValue!);\n      }\n    }, [controlledValue, handleValueChange, isControlled, value]);\n\n    // [*]... and when controlled, we don't trigger handleValueChange as the\n    // user types, instead the developer controls it with the normal input\n    // onChange prop\n    function handleChange(event: React.ChangeEvent<HTMLInputElement>) {\n      const { value } = event.target;\n      if (!isControlled) {\n        handleValueChange(value);\n      }\n    }\n\n    function handleFocus() {\n      if (selectOnClick) {\n        selectOnClickRef.current = true;\n      }\n\n      // If we select an option with click, useFocusManagement will focus the\n      // input, in those cases we don't want to cause the menu to open back up,\n      // so we guard behind these states.\n      if (openOnFocus && lastEventType !== SELECT_WITH_CLICK) {\n        transition(FOCUS);\n      }\n    }\n\n    function handleClick() {\n      if (selectOnClickRef.current) {\n        selectOnClickRef.current = false;\n        inputRef.current.select();\n      }\n    }\n\n    const inputValue =\n      autocomplete && (state === NAVIGATING || state === INTERACTING)\n        ? // When idle, we don't have a navigationValue on ArrowUp/Down\n          navigationValue || controlledValue || value\n        : controlledValue || value;\n\n    return (\n      <Comp\n        aria-activedescendant={\n          navigationValue ? String(makeHash(navigationValue)) : undefined\n        }\n        aria-autocomplete=\"both\"\n        aria-controls={listboxId}\n        aria-expanded={isExpanded}\n        aria-haspopup=\"listbox\"\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabel ? undefined : ariaLabelledby}\n        role=\"combobox\"\n        {...props}\n        data-reach-combobox-input=\"\"\n        ref={ref}\n        onBlur={wrapEvent(onBlur, handleBlur)}\n        onChange={wrapEvent(onChange, handleChange)}\n        onClick={wrapEvent(onClick, handleClick)}\n        onFocus={wrapEvent(onFocus, handleFocus)}\n        onKeyDown={wrapEvent(onKeyDown, handleKeyDown)}\n        value={inputValue || \"\"}\n      />\n    );\n  }\n);\n\n/**\n * @see Docs https://reach.tech/combobox#comboboxinput-props\n */\nexport type ComboboxInputProps = {\n  /**\n   * If true, when the user clicks inside the text box the current value will\n   * be selected. Use this if the user is likely to delete all the text anyway\n   * (like the URL bar in browsers).\n   *\n   * However, if the user is likely to want to tweak the value, leave this\n   * false, like a google search--the user is likely wanting to edit their\n   * search, not replace it completely.\n   *\n   * @see Docs https://reach.tech/combobox#comboboxinput-selectonclick\n   */\n  selectOnClick?: boolean;\n  /**\n   * Determines if the value in the input changes or not as the user navigates\n   * with the keyboard. If true, the value changes, if false the value doesn't\n   * change.\n   *\n   * Set this to false when you don't really need the value from the input but\n   * want to populate some other state (like the recipient selector in Gmail).\n   * But if your input is more like a normal `<input type=\"text\"/>`, then leave\n   * the `true` default.\n   *\n   * @see Docs https://reach.tech/combobox#comboboxinput-autocomplete\n   */\n  autocomplete?: boolean;\n  /**\n   * @see Docs https://reach.tech/combobox#comboboxinput-value\n   */\n  value?: ComboboxValue;\n};\n\nif (__DEV__) {\n  ComboboxInput.displayName = \"ComboboxInput\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxPopover\n *\n * Contains the popup that renders the list. Because some UI needs to render\n * more than the list in the popup, you need to render one of these around the\n * list. For example, maybe you want to render the number of results suggested.\n *\n * @see Docs https://reach.tech/combobox#comboboxpopover\n */\nexport const ComboboxPopover = forwardRefWithAs<\n  ComboboxPopoverProps & Partial<PopoverProps>,\n  \"div\"\n>(function ComboboxPopover(\n  {\n    as: Comp = \"div\",\n    children,\n    portal = true,\n    onKeyDown,\n    onBlur,\n    position = positionMatchWidth,\n    ...props\n  },\n  forwardedRef: React.Ref<any>\n) {\n  const { popoverRef, inputRef, isExpanded } = React.useContext(\n    ComboboxContext\n  );\n  const ref = useForkedRef(popoverRef, forwardedRef);\n  const handleKeyDown = useKeyDown();\n  const handleBlur = useBlur();\n\n  const sharedProps = {\n    \"data-reach-combobox-popover\": \"\",\n    onKeyDown: wrapEvent<any>(onKeyDown, handleKeyDown),\n    onBlur: wrapEvent<any>(onBlur, handleBlur),\n    // Instead of conditionally rendering the popover we use the `hidden` prop\n    // because we don't want to unmount on close (from escape or onSelect).\n    // However, the developer can conditionally render the ComboboxPopover if\n    // they do want to cause mount/unmount based on the app's own data (like\n    // results.length or whatever).\n    hidden: !isExpanded,\n    tabIndex: -1,\n    children,\n  };\n\n  return portal ? (\n    <Popover\n      as={Comp}\n      {...props}\n      ref={ref}\n      position={position}\n      targetRef={inputRef}\n      {...sharedProps}\n    />\n  ) : (\n    <Comp ref={ref} {...props} {...sharedProps} />\n  );\n});\n\nif (__DEV__) {\n  ComboboxPopover.displayName = \"ComboboxPopover\";\n}\n\n/**\n * @see Docs https://reach.tech/combobox#comboboxpopover-props\n */\nexport type ComboboxPopoverProps = {\n  /**\n   * If you pass `<ComboboxPopover portal={false} />` the popover will not\n   * render inside of a portal, but in the same order as the React tree. This\n   * is mostly useful for styling the entire component together, like the pink\n   * focus outline in the example earlier in this page.\n   *\n   * @see Docs https://reach.tech/combobox#comboboxpopover-portal\n   */\n  portal?: boolean;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxList\n *\n * Contains the `ComboboxOption` elements and sets up the proper aria attributes\n * for the list.\n *\n * @see Docs https://reach.tech/combobox#comboboxlist\n */\nexport const ComboboxList = forwardRefWithAs<ComboboxListProps, \"ul\">(\n  function ComboboxList(\n    {\n      // when true, and the list opens again, the option with a matching value\n      // will be automatically highlighted.\n      persistSelection = false,\n      as: Comp = \"ul\",\n      ...props\n    },\n    forwardedRef\n  ) {\n    const { persistSelectionRef, listboxId } = React.useContext(\n      ComboboxContext\n    );\n\n    if (persistSelection) {\n      persistSelectionRef.current = true;\n    }\n\n    return (\n      <Comp\n        role=\"listbox\"\n        {...props}\n        ref={forwardedRef}\n        data-reach-combobox-list=\"\"\n        id={listboxId}\n      />\n    );\n  }\n);\n\n/**\n * @see Docs https://reach.tech/combobox#comboboxlist-props\n */\nexport type ComboboxListProps = {\n  /**\n   * Defaults to false. When true and the list is opened, if an option's value\n   * matches the value in the input, it will automatically be highlighted and\n   * be the starting point for any keyboard navigation of the list.\n   *\n   * This allows you to treat a Combobox more like a `<select>` than an\n   * `<input/>`, but be mindful that the user is still able to put any\n   * arbitrary value into the input, so if the only valid values for the input\n   * are from the list, your app will need to do that validation on blur or\n   * submit of the form.\n   *\n   * @see Docs https://reach.tech/combobox#comboboxlist-persistselection\n   */\n  persistSelection?: boolean;\n};\n\nif (__DEV__) {\n  ComboboxList.displayName = \"ComboboxList\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxOption\n *\n * An option that is suggested to the user as they interact with the combobox.\n *\n * @see Docs https://reach.tech/combobox#comboboxoption\n */\nexport const ComboboxOption = forwardRefWithAs<ComboboxOptionProps, \"li\">(\n  function ComboboxOption(\n    { as: Comp = \"li\", children, value, onClick, ...props },\n    forwardedRef: React.Ref<any>\n  ) {\n    const {\n      onSelect,\n      data: { navigationValue },\n      transition,\n    } = React.useContext(ComboboxContext);\n\n    let ownRef = React.useRef<HTMLElement | null>(null);\n    let ref = useForkedRef(forwardedRef, ownRef);\n\n    let index = useDescendant(\n      {\n        element: ownRef.current!,\n        value,\n      },\n      ComboboxDescendantContext\n    );\n\n    const isActive = navigationValue === value;\n\n    const handleClick = () => {\n      onSelect && onSelect(value);\n      transition(SELECT_WITH_CLICK, { value });\n    };\n\n    return (\n      <OptionContext.Provider value={{ value, index }}>\n        <Comp\n          aria-selected={isActive}\n          role=\"option\"\n          {...props}\n          data-reach-combobox-option=\"\"\n          ref={ref}\n          id={String(makeHash(value))}\n          data-highlighted={isActive ? \"\" : undefined}\n          // Without this the menu will close from `onBlur`, but with it the\n          // element can be `document.activeElement` and then our focus checks in\n          // onBlur will work as intended\n          tabIndex={-1}\n          onClick={wrapEvent(onClick, handleClick)}\n          children={children || <ComboboxOptionText />}\n        />\n      </OptionContext.Provider>\n    );\n  }\n);\n\n/**\n * @see Docs https://reach.tech/combobox#comboboxoption-props\n */\nexport type ComboboxOptionProps = {\n  /**\n   * Optional. If omitted, the `value` will be used as the children like as:\n   * `<ComboboxOption value=\"Seattle, Tacoma, Washington\" />`. But if you need\n   * to control a bit more, you can put whatever children you want, but make\n   * sure to render a `ComboboxOptionText` as well, so the value is still\n   * displayed with the text highlighting on the matched portions.\n   *\n   * @example\n   *   <ComboboxOption value=\"Apple\" />\n   *     🍎 <ComboboxOptionText />\n   *   </ComboboxOption>\n   *\n   * @see Docs https://reach.tech/combobox#comboboxoption-children\n   */\n  children?: React.ReactNode;\n  /**\n   * The value to match against when suggesting.\n   *\n   * @see Docs https://reach.tech/combobox#comboboxoption-value\n   */\n  value: string;\n};\n\nif (__DEV__) {\n  ComboboxOption.displayName = \"ComboboxOption\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxOptionText\n *\n * Renders the value of a `ComboboxOption` as text but with spans wrapping the\n * matching and non-matching segments of text.\n *\n * We don't forwardRef or spread props because we render multiple spans or null,\n * should be fine 🤙\n *\n * @example\n *   <ComboboxOption value=\"Seattle\">\n *     🌧 <ComboboxOptionText />\n *   </ComboboxOption>\n *\n * @see Docs https://reach.tech/combobox#comboboxoptiontext\n */\nexport function ComboboxOptionText() {\n  const { value } = React.useContext(OptionContext);\n  const {\n    data: { value: contextValue },\n  } = React.useContext(ComboboxContext);\n\n  const results = React.useMemo(\n    () =>\n      findAll({\n        searchWords: escapeRegexp(contextValue || \"\").split(/\\s+/),\n        textToHighlight: value,\n      }),\n    [contextValue, value]\n  );\n\n  return (\n    <>\n      {results.length\n        ? results.map((result, index) => {\n            const str = value.slice(result.start, result.end);\n            return (\n              <span\n                key={index}\n                data-user-value={result.highlight ? true : undefined}\n                data-suggested-value={result.highlight ? undefined : true}\n              >\n                {str}\n              </span>\n            );\n          })\n        : value}\n    </>\n  );\n}\n\nif (__DEV__) {\n  ComboboxOptionText.displayName = \"ComboboxOptionText\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * ComboboxButton\n */\nexport const ComboboxButton = forwardRefWithAs<ComboboxButtonProps, \"button\">(\n  function ComboboxButton(\n    { as: Comp = \"button\", onClick, onKeyDown, ...props },\n    forwardedRef\n  ) {\n    const {\n      transition,\n      state,\n      buttonRef,\n      listboxId,\n      isExpanded,\n    } = React.useContext(ComboboxContext);\n    const ref = useForkedRef(buttonRef, forwardedRef);\n\n    const handleKeyDown = useKeyDown();\n\n    const handleClick = () => {\n      if (state === IDLE) {\n        transition(OPEN_WITH_BUTTON);\n      } else {\n        transition(CLOSE_WITH_BUTTON);\n      }\n    };\n\n    return (\n      <Comp\n        aria-controls={listboxId}\n        aria-haspopup=\"listbox\"\n        aria-expanded={isExpanded}\n        {...props}\n        data-reach-combobox-button=\"\"\n        ref={ref}\n        onClick={wrapEvent(onClick, handleClick)}\n        onKeyDown={wrapEvent(onKeyDown, handleKeyDown)}\n      />\n    );\n  }\n);\n\nexport type ComboboxButtonProps = {};\n\nif (__DEV__) {\n  ComboboxButton.displayName = \"ComboboxButton\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Move focus back to the input if we start navigating w/ the\n * keyboard after focus has moved to any focusable content in\n * the popup.\n *\n * @param lastEventType\n * @param inputRef\n */\nfunction useFocusManagement(\n  lastEventType: MachineEventType | undefined,\n  inputRef: React.MutableRefObject<any>\n) {\n  // useLayoutEffect so that the cursor goes to the end of the input instead\n  // of awkwardly at the beginning, unclear to me why 🤷‍♂️\n  //\n  // Should be safe to use here since we're just focusing an input.\n  useIsomorphicLayoutEffect(() => {\n    if (\n      lastEventType === NAVIGATE ||\n      lastEventType === ESCAPE ||\n      lastEventType === SELECT_WITH_CLICK ||\n      lastEventType === OPEN_WITH_BUTTON\n    ) {\n      inputRef.current.focus();\n    }\n  }, [inputRef, lastEventType]);\n}\n\n/**\n * We want the same events when the input or the popup have focus (HOW COOL ARE\n * HOOKS BTW?) This is probably the hairiest piece but it's not bad.\n */\nfunction useKeyDown() {\n  const {\n    data: { navigationValue },\n    onSelect,\n    state,\n    transition,\n    autocompletePropRef,\n    persistSelectionRef,\n  } = React.useContext(ComboboxContext);\n\n  const options = useDescendants(ComboboxDescendantContext);\n\n  return function handleKeyDown(event: React.KeyboardEvent) {\n    let index = options.findIndex(({ value }) => value === navigationValue);\n\n    function getNextOption() {\n      let atBottom = index === options.length - 1;\n      if (atBottom) {\n        if (autocompletePropRef.current) {\n          // Go back to the value the user has typed because we are\n          // autocompleting and they need to be able to get back to what\n          // they had typed w/o having to backspace out.\n          return null;\n        } else {\n          // cycle through\n          return getFirstOption();\n        }\n      } else {\n        // Go to the next item in the list\n        return options[(index + 1) % options.length];\n      }\n    }\n\n    function getPreviousOption() {\n      let atTop = index === 0;\n      if (atTop) {\n        if (autocompletePropRef.current) {\n          // Go back to the value the user has typed because we are\n          // autocompleting and they need to be able to get back to what\n          // they had typed w/o having to backspace out.\n          return null;\n        } else {\n          // cycle through\n          return getLastOption();\n        }\n      } else if (index === -1) {\n        // displaying the user's value, so go select the last one\n        return getLastOption();\n      } else {\n        // normal case, select previous\n        return options[(index - 1 + options.length) % options.length];\n      }\n    }\n\n    function getFirstOption() {\n      return options[0];\n    }\n\n    function getLastOption() {\n      return options[options.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        // Don't scroll the page\n        event.preventDefault();\n        if (!options || !options.length) {\n          return;\n        }\n\n        if (state === IDLE) {\n          // Opening a closed list\n          transition(NAVIGATE, {\n            persistSelection: persistSelectionRef.current,\n          });\n        } else {\n          let next = getNextOption();\n          transition(NAVIGATE, { value: next ? next.value : null });\n        }\n        break;\n\n      // A lot of duplicate code with ArrowDown up next, I'm already over it.\n      case \"ArrowUp\":\n        // Don't scroll the page\n        event.preventDefault();\n        if (!options || options.length === 0) {\n          return;\n        }\n\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          let prev = getPreviousOption();\n          transition(NAVIGATE, { value: prev ? prev.value : null });\n        }\n        break;\n\n      case \"Home\":\n      case \"PageUp\":\n        // Don't scroll the page\n        event.preventDefault();\n        if (!options || options.length === 0) {\n          return;\n        }\n\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          transition(NAVIGATE, { value: getFirstOption().value });\n        }\n        break;\n\n      case \"End\":\n      case \"PageDown\":\n        // Don't scroll the page\n        event.preventDefault();\n        if (!options || options.length === 0) {\n          return;\n        }\n\n        if (state === IDLE) {\n          transition(NAVIGATE);\n        } else {\n          transition(NAVIGATE, { value: getLastOption().value });\n        }\n        break;\n\n      case \"Escape\":\n        if (state !== IDLE) {\n          transition(ESCAPE);\n        }\n        break;\n      case \"Enter\":\n        if (state === NAVIGATING && navigationValue !== null) {\n          // don't want to submit forms\n          event.preventDefault();\n          onSelect && onSelect(navigationValue);\n          transition(SELECT_WITH_KEYBOARD);\n        }\n        break;\n    }\n  };\n}\n\nfunction useBlur() {\n  const {\n    state,\n    transition,\n    popoverRef,\n    inputRef,\n    buttonRef,\n  } = React.useContext(ComboboxContext);\n  const rafIds = useLazyRef(() => new Set<number>());\n\n  React.useEffect(() => {\n    return () => {\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      rafIds.current.forEach((id) => cancelAnimationFrame(id));\n    };\n  }, [rafIds]);\n\n  return function handleBlur() {\n    const ownerDocument = getOwnerDocument(popoverRef.current);\n    if (!ownerDocument) {\n      return;\n    }\n\n    let rafId = requestAnimationFrame(() => {\n      // we on want to close only if focus propss outside the combobox\n      if (\n        ownerDocument.activeElement !== inputRef.current &&\n        ownerDocument.activeElement !== buttonRef.current &&\n        popoverRef.current\n      ) {\n        if (popoverRef.current.contains(ownerDocument.activeElement)) {\n          // focus landed inside the combobox, keep it open\n          if (state !== INTERACTING) {\n            transition(INTERACT);\n          }\n        } else {\n          // focus landed outside the combobox, close it.\n          transition(BLUR);\n        }\n      }\n    });\n    rafIds.current.add(rafId);\n  };\n}\n\n/**\n * This manages transitions between states with a built in reducer to manage\n * the data that goes with those transitions.\n *\n * @param chart\n * @param reducer\n * @param initialData\n */\nfunction useReducerMachine(\n  chart: StateChart,\n  reducer: Reducer,\n  initialData: Partial<StateData>\n): [State, StateData, Transition] {\n  const [state, setState] = React.useState(chart.initial);\n  const [data, dispatch] = React.useReducer(reducer, initialData);\n\n  const transition: Transition = (event, payload = {}) => {\n    const currentState = chart.states[state];\n    const nextState = currentState && currentState.on[event];\n    if (nextState) {\n      dispatch({ type: event, state, nextState: state, ...payload });\n      setState(nextState);\n      return;\n    }\n  };\n\n  return [state, data, transition];\n}\n\n/**\n * We don't want to track the active descendant with indexes because nothing is\n * more annoying in a combobox than having it change values RIGHT AS YOU HIT\n * ENTER. That only happens if you use the index as your data, rather than\n * *your data as your data*. We use this to generate a unique ID based on the\n * value of each item.  This function is short, sweet, and good enough™ (I also\n * don't know how it works, tbqh)\n *\n * @see https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript\n * @param str\n */\nconst makeHash = (str: string) => {\n  let hash = 0;\n  if (str.length === 0) {\n    return hash;\n  }\n  for (let i = 0; i < str.length; i++) {\n    var char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash;\n  }\n  return hash;\n};\n\n/**\n * Escape regexp special characters in `str`\n *\n * @see https://github.com/component/escape-regexp/blob/5ce923c1510c9802b3da972c90b6861dd2829b6b/index.js\n * @param str\n */\n\nexport function escapeRegexp(str: string) {\n  return String(str).replace(/([.*+?=^!:${}()|[\\]/\\\\])/g, \"\\\\$1\");\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hook that exposes data for a given `Combobox` component to its descendants.\n *\n * @see Docs https://reach.tech/combobox#usecomboboxcontext\n */\nexport function useComboboxContext(): ComboboxContextValue {\n  let { isExpanded, comboboxId } = React.useContext(ComboboxContext);\n  return React.useMemo(\n    () => ({\n      id: comboboxId,\n      isExpanded,\n    }),\n    [comboboxId, isExpanded]\n  );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Well alright, you made it all the way here to like 1100 lines of code (geez,\n// what the heck?). Have a great day :D\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\nexport type ComboboxContextValue = {\n  id: string | undefined;\n  isExpanded: boolean;\n};\n\ntype ComboboxDescendant = Descendant<HTMLElement> & {\n  value: ComboboxValue;\n};\n\ninterface ComboboxOptionContextValue {\n  value: ComboboxValue;\n  index: number;\n}\n\ninterface InternalComboboxContextValue {\n  ariaLabel?: string;\n  ariaLabelledby?: string;\n  autocompletePropRef: React.MutableRefObject<any>;\n  buttonRef: React.MutableRefObject<any>;\n  comboboxId: string | undefined;\n  data: StateData;\n  inputRef: React.MutableRefObject<any>;\n  isExpanded: boolean;\n  listboxId: string;\n  onSelect(value?: ComboboxValue): any;\n  openOnFocus: boolean;\n  persistSelectionRef: React.MutableRefObject<any>;\n  popoverRef: React.MutableRefObject<any>;\n  state: State;\n  transition: Transition;\n}\n\ntype Transition = (event: MachineEventType, payload?: any) => any;\n\ntype ComboboxValue = string;\n\ntype State = \"IDLE\" | \"SUGGESTING\" | \"NAVIGATING\" | \"INTERACTING\";\n\ntype MachineEventType =\n  | \"CLEAR\"\n  | \"CHANGE\"\n  | \"INITIAL_CHANGE\"\n  | \"NAVIGATE\"\n  | \"SELECT_WITH_KEYBOARD\"\n  | \"SELECT_WITH_CLICK\"\n  | \"ESCAPE\"\n  | \"BLUR\"\n  | \"INTERACT\"\n  | \"FOCUS\"\n  | \"OPEN_WITH_BUTTON\"\n  | \"CLOSE_WITH_BUTTON\";\n\ninterface StateChart {\n  initial: State;\n  states: {\n    [key in State]?: {\n      on: {\n        [key in MachineEventType]?: State;\n      };\n    };\n  };\n}\n\ntype StateData = {\n  lastEventType?: MachineEventType;\n  navigationValue?: ComboboxValue | null;\n  value?: ComboboxValue | null;\n};\n\ntype MachineEvent =\n  | { type: \"BLUR\" }\n  | { type: \"CHANGE\"; value: ComboboxValue }\n  | { type: \"INITIAL_CHANGE\"; value: ComboboxValue }\n  | { type: \"CLEAR\" }\n  | { type: \"CLOSE_WITH_BUTTON\" }\n  | { type: \"ESCAPE\" }\n  | { type: \"FOCUS\" }\n  | { type: \"INTERACT\" }\n  | {\n      type: \"NAVIGATE\";\n      persistSelection?: React.MutableRefObject<any>;\n      value: ComboboxValue;\n    }\n  | { type: \"OPEN_WITH_BUTTON\" }\n  | {\n      type: \"SELECT_WITH_CLICK\";\n      value: ComboboxValue;\n    }\n  | {\n      type: \"SELECT_WITH_KEYBOARD\";\n    };\n\ntype Reducer = (data: StateData, event: MachineEvent) => StateData;\n"]},"metadata":{},"sourceType":"module"}